# Linux Fu:远程执行变得容易

> 原文：<https://hackaday.com/2020/08/11/linux-fu-remote-execution-made-easy/>

如果您设置了 SSH 和一些其他工具，那么登录到另一台机器并运行一些程序是非常容易的。当您使用的机器可能没有太多内存或处理能力，并且您可以访问网络上某个更大的机器时，这可能会很方便。例如，假设您想在一台用作媒体服务器的机器上对一些视频进行重新编码，但它在拥有十几个内核和 32gb RAM 的巨型服务器上运行速度会快得多。

## 远程执行

然而，这种情况存在一些问题。首先，您可能没有在远程机器上安装软件。即使您这样做了，它也可能不是您期望的版本，或者与您的本地副本具有完全相同的配置。然后就是文件问题。输入文件应该来自您的本地文件系统，并且您希望输出也在那里结束。当然，这些并不是不可克服的。你可以在遥控盒上安装程序，手动来回复制你的文件。或者可以用[跑得比](https://github.com/Overv/outrun)快。

不过，还是有一些限制。您确实需要在两台机器上运行，并且两台机器必须具有相同的 CPU 架构。遗憾的是，这意味着您不能使用它从 Raspberry Pi 在 x86-64 PC 上轻松运行作业。您还需要对远程机器的 root 访问权限。该系统还依赖于 FUSE 文件系统库的设置。

## 一个简单的想法

这个想法很简单。你可以像这样做一个视频编码:

```
outrun user@host ffmpeg -i input.mp4 -vcodec libx265 -crf 28 output.mp4
```

即使 ffmpeg 不在远程机器上，并且输入和输出文件在您期望的本地机器上，这也能工作。以下是该项目的 GitHub 页面截图:

[![](img/110388cbbe5480cca987a892dbbd1428.png)](https://hackaday.com/wp-content/uploads/2020/07/outrun.gif)

## 复杂的实现

这是如何工作的？FUSE 文件系统使用轻量级 RPC 文件系统远程挂载您的本地文件系统。然后一个`chroot`让远程机器看起来就像你的本地机器一样，但是——大概——更快。还需要做一些其他的事情，比如设置环境和当前目录。

顺便说一下，`chroot`就是为什么您需要远程机器上的 root。作为一个普通用户，你不能通过改变根文件系统来使这一招奏效。

为了提高性能，Outrun 缓存系统目录，并假设它们在命令的生命周期中不会改变。它还使用一些启发式方法积极地预取，猜测除了系统要求的文件之外，您还需要什么文件。

## 未来

我们希望有一个选项来假设程序将在远程机器上执行，并且只设置输入和输出文件。举例来说，这将使在远程电脑上从运行 Octoprint 的 Raspberry Pi 中切割 3D 打印更加容易。当然，这都是开源的，所以也许我们应该自己解决这个问题。

同样，你可以用 [sshfs](https://hackaday.com/2019/12/17/linux-fu-stupid-ssh-tricks/) 和其他一些技巧很容易地做这样的事情。如果你想在一堆远程机器上运行一个程序，[也有办法做到](https://hackaday.com/2020/06/29/linux-fu-parallel-universe/)。