# 窥视运行中的大脑:从用户空间分析 SDRAM 刷新

> 原文:[https://hack aday . com/2018/12/28/peering-into-a running-brain-SDRAM-refresh-analyzed-from-user space-code/](https://hackaday.com/2018/12/28/peering-into-a-running-brain-sdram-refresh-analyzed-from-userspace-code/)

在 Cloudflare 博客上，[Marek]发现自己对计算机内存感到疑惑，就像我们有时会做的那样。具体来说，他考虑是否能从一个运行的程序中检测到 SDRAM 的刷新。我们告诉你答案是肯定的，这可能不会破坏惊喜——在我们的老朋友快速傅立叶变换(FFT)的帮助下，仅用了 100 多行 C 代码，[Marek]就能够每 7818.6 ns 检测一次 SDRAM 刷新周期，与预期结果完全一致。

SDRAM 中的“D”代表动态，这意味着除非通过读写定期刷新，否则存储器中的数据将会衰减。在这种存储器中，每一位都以电荷的形式存储在一个微小的电容器上。给定足够的时间(随环境温度而变化)，这些电荷会泄漏到邻近的硅上，将所有的 1 变为 0，并破坏数据。为了应对这一过程，存储器控制器周期性地发出刷新命令，该命令在数据衰减之前读取数据，然后写回数据以再次对电容器完全充电。如果做得足够频繁，这将无限期地保存内存内容。与替代方案相比，SDRAM 相对便宜且容量大，但缺点是 CPU 无法访问正在刷新的那部分内存，因此每当内存访问和刷新周期发生冲突时，执行都会有所延迟。

## 追逐正确的打嗝

[Marek]认为他可以通过运行一些内存访问并在一个严格的循环中记录当前时间来检测这个“打嗝”，正如他所说的那样。当然，现代 CPU 上的缓存意味着对于少量数据，SDRAM 永远不会被访问，所以他每次都刷新缓存。GitHub 上提供的[源代码输出了内循环每次迭代所用的时间。在他的例子中，循环通常需要大约 140 ns。](https://github.com/cloudflare/cloudflare-blog/blob/master/2018-11-memory-refresh/measure-dram.c)

> 万岁！第一个频率尖峰确实是我们所期待的，并且确实与刷新时间相关。
> 
> 256kHz、384kHz、512kHz 等处的其他尖峰是 128kHz 基频的倍数，称为谐波。这是在方波等波形上执行 FFT 的副作用，完全在意料之中。

正如(马雷克)所指出的，原始数据没有透露太多信息。毕竟，在一个现代的多任务操作系统中，有很多事情会导致很小的延迟，从而导致非常嘈杂的数据。即使对数据进行阈值处理和重采样，也不会导致刷新中断。为了检测 SDRAM 刷新周期，他求助于 FFT，这是一种计算[离散傅立叶变换](https://en.wikipedia.org/wiki/Discrete_Fourier_transform)的有效算法，擅长揭示周期性。几行 python 代码产生了想要的结果:一个延长循环迭代的频谱图。放大后，他发现第一个频率尖峰位于 127.9 kHz，对应于 7.81 us 的 SDRAMs 刷新周期，同时还有许多其他尖峰代表此基频的谐波。为了方便他人的实验，[Marek]创建了一个可以在您自己的机器上运行的工具的[命令行版本。](https://github.com/cloudflare/cloudflare-blog/tree/master/2018-11-memory-refresh)

如果这种技术看起来很熟悉，可能是因为它类似于我们在 2015 年报道的 [Rowhammer 攻击，它可以通过快速访问相邻行来改变易受攻击机器上 SDRAM 中的数据。正如[Marek]指出的，你可以从用户空间程序中进行这种测量的事实可能会有深远的安全影响，正如我们在](https://hackaday.com/2015/03/13/creative-dram-abuse-with-rowhammer/)[灾难和幽灵攻击](https://hackaday.com/2018/01/05/lets-talk-intel-meltdown-and-spectre/)中看到的那样。我们不得不思考我们的机器内部还有哪些漏洞等待被发现。

感谢[anfractuous]的提示！