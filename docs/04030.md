# Linux Fu:C、C++和其他语言中的 Shell 脚本

> 原文:[https://hack aday . com/2019/09/17/Linux-fu-shell-scripts-in-c-c-and-others/](https://hackaday.com/2019/09/17/linux-fu-shell-scripts-in-c-c-and-others/)

乍一看，用 C/C++编写 shell 脚本似乎没有意义。毕竟，shell 脚本的全部目的就是快速而肮脏地删除一些东西。然而，在某些情况下，您可能希望编写一个快速的 C 程序来做一些用传统脚本语言很难做到的事情，也许您有一个库来简化这项工作，或者也许您只懂 C，可以更快地完成它。

虽然 C 可以生成可执行文件，所以不需要脚本，但通常，当你只是想完成某件事时，构建可执行文件的设置并不是你想花时间去做的事情。此外，脚本在很大程度上是可移植的。但是将一个可执行文件发送给其他人是相当冒险的——但是你很幸运，因为 C shell 脚本可以作为脚本共享。一种选择是使用像[紧贴](https://cdn.rawgit.com/root-project/cling/master/www/index.html)这样的 C 解释器。当你在[使用 Jupyter notebook](https://hackaday.com/2019/02/22/drops-of-jupyter-notebooks-how-to-keep-notes-in-the-information-age/) 之类的东西时，这尤其常见。然而，它是用户系统上需要的另一个软件。除了 system C 编译器(很可能是 gcc)之外，最好不要依赖其他任何东西。

幸运的是，有几种方法可以做到这一点，而且没有一种特别难。即使你不想用 C 语言写脚本，理解如何到达那里也是很有帮助的。

## 整个事情

我假设你的 shell 是 Bash。shell 之间可能有细微的差别，但是 shell 通常支持一种称为 shebang 的启动脚本的方式——它使用散列和感叹号(！)你可能在脚本的顶部见过。

![](../Images/ed316a421046a52c9f43869e3e8f0667.png)当 Bash 看到你试图执行一个文件时，它会像[文件](https://linux.die.net/man/1/file)一样，使用一个神奇的数字查找来找出它是什么类型的文件。file 命令实际上使用了一个名为“magic”的库来完成这项工作，您可以运行`man magic`来查看正在工作的各种数据库。理论上，有一个文本表示和一个编译版本，但是许多常见的发行版在默认情况下不安装源代码。不管怎样，数据库在文件中寻找某些幻数来确定它们的类型——例如，程序不需要依赖文件扩展名。

确切的格式并不重要，但是一个典型的条目有一个偏移量来查看文件内部，还有一个数字或模式来匹配。在 shell 脚本的情况下，幻数是 0x23 0x21，当然是`#!`。特别是，执行某些操作的系统调用可以区分 shell 脚本和随机文本文件。

通常，您会看到类似于`#!/usr/bin/bash`的内容，这导致文件作为 Bash 脚本运行。当然，这硬编码了 bash 的系统副本的位置。有些人认为这很好，因为你认为你有机会获得 Bash 的已知副本。其他人认为，如果你的个人目录中有 Bash 的升级版本，它就不会使用它。如果您同意后一组，您可以尝试`#!/usr/bin/env bash`——它仍然硬编码一个路径，但是可执行文件只设置环境。

不过，解释器不必是 Bash，甚至不必是一个合适的 shell。例如，Awk 程序可能将`#!/usr/bin/awk -f`作为第一行。因此，一种策略是构建一个可以“启动”底层 C“脚本”的脚本

这是一种方法，但我采取了不同的方法。我最初的想法是，由于`#!`看起来像一个预处理器语句，所以 C 编译器可以直接使用一个脚本文件。这在过去可能是正确的，但是现代的预处理器在看到它不期望的东西时会抛出一个错误。

## 将 C 文件标记为 Bash 脚本

我想让事情变得简单。在一个独立的 C 文件的最前面的下面几行就足以让事情正常进行了:

```
#!/usr/bin/env bash
#if 0
source cscript_simplec
#endif
```

第一行告诉系统这是一个 Bash 脚本。您可能想知道，当我试图使用 c 语言时，为什么我会将它标记为 Bash 脚本。#if 和#endif 语句只是 Bash 的注释。source 命令告诉 shell 从目录路径的某个地方读取 cscript_simplec。

这种来源永远不会回来，所以什么是没有关系的 Bash 之后。但是，如果可执行文件过期，这个文件将被传递给 gcc。假设这个文件是`example.c`。同一个目录下会有一个可执行文件`example.c.bin`。(这意味着第一个运行脚本的人需要对目录有写权限。)

如果二进制文件比源文件新，我们只需使用 exec 运行它。这导致程序覆盖 Bash 的当前副本，与只运行新程序相比，节省了一点内存。但是，如果源文件较新，脚本会首先重建二进制文件。

有一个小问题。尽管文件的大部分是合法的 C 语言，但第一行不是。然而，这条线对这家初创公司至关重要。答案是切断那条线。下面是 cscript_simplec 的样子:

```

if [ "$0" -nt "$0.bin" ]
then
  CCOPTS="${CCOPTS:--O3}"
  if ! tail -n +2 "$0" | gcc -x c "${CCOPTS}" -o "$0.bin" -
  then
    echo Compile Error on $0
    exit 999
  fi
fi
exec "$0.bin"

```

第 10 行的最后一个命令切断第一行，并通过管道输入 gcc。因为没有文件名，我们必须告诉 gcc 它正在读取一个 C 文件(-x 选项)。您可以设置 CCOPTS，否则它将默认为-O3。

当然，如果您要将它发送到野外，您可能希望在脚本中包含这整个块(或类似的东西),而放弃源命令。那会有用的。

## 复杂性

很容易为 C++等不同的东西更改代码。因为这是脚本，所以可以很安全地假设只有一个文件，并且可执行文件直接依赖于源文件。然而，如果你想要更复杂一点——有些人会为一个简单的脚本争论不休——你可以转向 make。

如果你想试试的话，把`cscript_simplec`换成`cscript_make`。您还必须提供一个 makefile(在本例中为 example.c.make)。一个合适的例子是:

```
$(SCRIPT_OUT_NAME):$(SCRIPT_NAME)
       gcc -x c $(SCRIPT_NAME) -o $(SCRIPT_OUT_NAME)
```

注意你必须使用`$(SCRIPT_NAME)`作为源文件，使用`$(SCRIPT_OUT_NAME)`作为可执行文件。当然，这是一个愚蠢的例子，但是您可以使用 makefile 创建一组复杂的依赖项和编译选项。另一方面，这似乎违反了简单原则，因此在这种情况下，您可能最好只编写一个普通的 C 程序。

如果你真的需要一种高级脚本语言，你可以考虑 [Python](https://hackaday.com/2015/01/20/learning-python-with-tron-radio/) 或者其他可用的解释语言。然而，理解这种机制以及如何颠覆 C 编译器，也许有一天会派上用场。毕竟，你可以用预处理器和编译器完成一些[丑陋/美丽的黑客行为。](https://hackaday.com/2015/08/06/hacking-a-universal-assembler/)