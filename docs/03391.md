# 程序性能上的缓存

> 原文：<https://hackaday.com/2019/06/23/caching-in-on-program-performance/>

我们大多数人对计算机如何工作都有一个非常简单的模型。CPU 从内存中获取指令和数据，执行它们，并将数据写回内存。对于我们所做的大多数事情来说，这个模型是一个足够好的抽象，但是除了最简单的计算机之外，它在很长一段时间内都不是真的。现代计算机的内存子系统要复杂得多，而且往往是真正发挥性能的关键。[Pdziepak]有一篇关于如何[利用现代缓存](https://pdziepak.github.io/2019/06/21/avoiding-icache-misses/)来提高高性能代码的精彩文章。

如果你回到 1956 年，[汤姆·基尔本的]阿特拉斯计算机基于[弗里茨-鲁道夫·根茨]的一篇博士论文的工作引入了虚拟内存。这个想法是，少量的高速存储器可以容纳更大的存储设备，如磁鼓、磁带或磁盘。如果一个程序访问不在高速存储器中的一块存储器，在可能通过将工作存储器的某些部分写回大容量存储设备来腾出空间之后，系统从大容量存储设备中读取。

缓存更进一步。CPU 从一个很小但非常快的缓存中执行代码。较大且较慢的缓存充当 fast cache 的大容量存储。该高速缓存可以具有其自己的高速缓存，直到最终其中一个高速缓存清空到大容量存储设备中。当然，由于目的不同，所以存在一些差异:高速缓存主要关注更快的内存访问，而虚拟内存试图允许大型程序在更少的物理内存中运行。

然而，这与我们常见的心理模型有很大不同。实际上，今天的现代 CPU 从海量存储器中执行程序。这就是为什么你可以在一台内存有限的计算机上运行许多庞大的程序。然而，CPU 实际上是从一个非常小的高速内存中执行的。

现代高速缓存通常分为指令和数据两部分，而[Pdziepak]专门针对一级指令高速缓存。它变得非常详细，但它确实谈到了检查缓存性能的工具，还谈到了热和冷函数，我们认为这些工具没有得到足够的使用。

当然，如果你只是写正常的代码，你可能不会在意。但是，如果你想从你的 CPU 中获得最大的性能，你会喜欢这篇文章的。

不幸的是，[缓存最近有一个坏的安全报告](https://hackaday.com/2018/01/15/spectre-and-meltdown-how-cache-works/)。尽管《毁灭战士》和《幽灵党》占据了媒体的大部分版面，但也有《T2》的伏笔。