# 在排队棱镜上反射会导致意想不到的结果

> 原文：<https://hackaday.com/2022/05/07/reflecting-on-a-queueing-prism-leads-to-unexpected-results/>

当只有一个线程执行一项任务时，计算机很难进行推理。在当今的现代处理器世界中，有几十个内核，您的程序可能会尝试利用多个内核。同时发生的事情使得状态和相互作用的数量激增到我们人类可能难以理解的混乱状态。所以，像[Hillel]一样，你可能会求助于计算机来尝试和模拟这些交互作用。

正在讨论的模型是一个任务队列。东西被添加到堆里，“工人”从堆里抓一个来加工。有两个指标用于衡量任务队列的有效性:吞吐量和延迟。吞吐量是你每秒可以做的事情的数量(就像这个[最大吞吐量 3d 打印机](https://hackaday.com/2021/12/26/maximum-throughput-benchie/))，而延迟是完成一件事情所需要的时间。

[Hillel]没有写模拟，而是求助于一个叫做 PRISM 的概率模型检查器。该模型有一些限制，例如每个任务都是相互依赖的，并且需要不同的时间来完成。这是由一个事实模拟的，即工人的每一步都有 50%的机会完成他们的任务。对于每一步，都有 50%的机会有一个新任务进入队列，最多不超过 N 个任务。接下来，他通过创建一个奖励函数来模拟吞吐量，该函数给出了我们完成所有任务所需的总步骤数。等待时间是另一个奖励函数，但是，它是每个时间步长中队列中项目数量的总和。

只有一名员工时，延迟的增长看起来是二次的。仅仅十个任务等待 29 次步骤，而 20 个任务等待 97 次步骤。当添加第二个工人时，吞吐量不会翻倍，而是只有一个工人的 2/3。但另一方面，延迟已经下降到接近线性。

虽然一个简单的模型，一个模型模拟一个复杂领域的想法是存在的。您可以轻松地添加优先级、更多工作线程、重试、将项目添加回队列、在一个时间步长中添加多个项目，以及其他事情。[Hillel] [提供了一点 python 要点](https://gist.github.com/hwayne/00ec2cef54a3031ec304ccb44eeaa42a)来帮助您为任意数量的工人生成棱柱。

正式方法/验证不是我们在 Hackaday 上经常谈论的东西，如果你想了解更多，[我们讨论了如何验证你的 C 编译器是可信的](https://hackaday.com/2019/01/24/can-you-trust-your-c-compiler/)。