# 二进制数学技巧:移位除以十并不容易

> 原文:[https://hack aday . com/2020/06/12/binary-math-tricks-shift-to-divide-by-ten-aint-easy/](https://hackaday.com/2020/06/12/binary-math-tricks-shifting-to-divide-by-ten-aint-easy/)

在小型 CPU 上，通常没有乘法或除法指令。当然，好的程序员都知道左右移位会乘以或除以 2 的幂。但是总有这样的情况，你需要使用不是 2 的幂的东西。有时候你可以用乘法算出来。

例如，在处理二进制和十进制之间的转换时，乘以 10 是很常见的。但是因为`10n`等于`8n+2n`，你可以把它表示为一串左移三次乘以八，把那个值加到你左移一次的原始值上乘以二。

但是分裂是一个不同的问题。`n/10`不等于`n/8-n/2`或其他类似的简单事物。前几天，一个朋友给我看了[一段非常复杂的关于用户[realtime]堆栈溢出](https://stackoverflow.com/questions/5558492/divide-by-10-using-bit-shifts)的代码片段，它将一个数除以 10，想知道它是如何工作的。如果你坚持数学，这是非常简单的，我会在这篇文章中向你展示我的意思。原来这个帖子引用了德高望重的黑客的《快乐书》,里面有很多这样的小技巧。

## 第一次乘法

首先，让我们做一些乘法的移位。每次左移都是 2 的幂，所以`n<<1`是`2*n`，`n<<8`是`256*n`。那很简单。困难的部分是把它分解成 2 的非幂:`n<<3 + n<<1`和`n*10`一样

如果您在装配中一次做一个班次，您通常可以通过合并两个班次来节省一点时间:

MOV A，T；将 A 移至临时存储器
SHL A
SHL A
添加 A，T；把 T 加到 A 上

即使在可以相乘的处理器上，这也是非常高效的。

## 除法转换是可行的，但合成却很棘手

除法也是这样，但是结合的不好。所以`n>>1`是 n/2，`n>>8`是 n/256。但是没有简单的方法像乘法一样结合除法。

我们看到的代码是这样的:

```

unsigned divu10(unsigned n) {
  unsigned q, r;
  q = (n >> 1) + (n >> 2);
  q = q + (q >> 4);
  q = q + (q >> 8);
  q = q + (q >> 16);
  q = q >> 3;
  r = n - (((q << 2) + q) << 1); return q + (r > 9);
}

```

真拗口！但它确实有效。理解这一点的秘诀是把每一次移位看作是数字的一部分。请看第一条工作线:

`q=(n>>1)+(n>>2)`

这真的是`n/2 + n/4`。如果你还记得你的高中数学，那就和`3n/4`一样。当然，这和乘以 0.75 是一样的。如果你向前看 q 的最后一个作业，你会得到一个线索:`q=q>>3;`

那就是说`q = q/8`。因此，如果我们的目标是除以 10，可能更容易认为是乘以 0.1。为了更好地适应 2 的幂，我们真的要考虑将整个乘以 0.8，然后除以 8。

所以两次右移加一次右移得到 0.75，离 0.8 不太远，但也不太远。下一行给我们的 0.75 因子增加了一点点。多了多少？金额为`3n/64`，现在总计为`51n/64`。这相当于 0.797 左右。已经接近 0.8 了。每一项都增加一点，让我们更接近一点。下面是它是如何分解的:最后一个学期只让你更接近了一点点。`13107n/16384`任期也差不多了。

| 表示 | 基准数 | 三角洲 | 总值 | 比例 |
| (n>>1)+n(>>2) | 3n/4 | Zero | 3n/4 | Zero point seven five |
| q+(q>>4) | 3n/4 + (3n/4)/16 | 3n/64 | 51n/64 | 0.7969 |
| q+(q>>8) | 51n/64+(51n/64)/256 | 51n/16384 | 13107n/16384 | 0.7999 |
| q+(q>>16) | 13107n/16384+(13107n/16384)/65536 | 13107n/1073741824 | 858993458n/1073741824 | Zero point eight |

我不禁想到，这在 FPGA 中很容易实现。

## 注释代码

下面是带注释的代码，它更容易理解:

```

unsigned divu10(unsigned n) {
  unsigned q, r;
  q = (n >> 1) + (n >> 2); // q=n/2+n/4 = 3n/4
  q = q + (q >> 4);        // q=3n/4+(3n/4)/16 = 3n/4+3n/64 = 51n/64
  q = q + (q >> 8);        // q=51n/64+(51n/64)/256 = 51n/64 + 51n/16384 = 13107n/16384 q = q + (q >> 16); // q= 13107n/16384+(13107n/16384)/65536=13107n/16348+13107n/1073741824=858993458n/1073741824
  // note: q is now roughly 0.8n
  q = q >> 3;              // q=n/8 = (about 0.1n or n/10)
  r = n - (((q << 2) + q) << 1); // rounding: r= n-2*(n/10*4+n/10)=n-2*5n/10=n-10n/10
  return q + (r > 9);      // adjust answer by error term
}

```

一旦你把它分解开来，就不难理解了。这种方法可以追溯到很久以前，看起来最初的来源是《黑客的喜悦》一书*(见第二版中的图 10-12)。我找不到相关的网站，但有一个[档案副本](https://web.archive.org/web/20190915025154/http://www.hackersdelight.org/)。这段代码中唯一的不同是最后一行被注释掉，替换为:`return q+((r+6)>>4);`*

 *这本书解释了如何找出最佳的转变，并增加和给出了几个其他的例子。那一章里还有很多其他的除法招数。如果你喜欢这类东西，可以看看 [bit twiddling hacks](https://hackaday.com/2020/01/16/these-bit-twiddling-tricks-will-make-your-coworkers-hate-you/) 页面。如果你的组织梦倾向于浮点，你可能[会发现这很有趣](https://hackaday.com/2012/07/15/a-detailed-explanation-on-speeding-up-avr-division/)。*