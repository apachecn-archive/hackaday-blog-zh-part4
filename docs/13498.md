# Linux Fu:无限串口

> 原文:[https://hack aday . com/2022/05/03/Linux-fu-the-infinite-serial-port/](https://hackaday.com/2022/05/03/linux-fu-the-infinite-serial-port/)

好吧，标题有点误导。像生活中的大多数事情一样，它真的不是无限的。但是我将向您展示如何使用一个非常有趣的 Linux 特性，将微控制器的一个串行端口变成一组虚拟端口。理论上，您可以创建超过 200 个端口，但实际情况是您可能想要更少的端口。

这个特性被称为伪终端，有时也称为`pty`或`pts`。这些特殊的文件是用来向那些希望从终端接收数据的程序提供数据的。这些文件提供了两个面。对于客户端来说，它看起来像任何其他终端设备。然而，对于创建者来说，它只是另一个文件。你写到那个文件的内容会传到假的终端，你可以读取连接到终端的程序发送的任何内容。你可能一直在使用这些工具，却没有意识到这一点，因为在 X Windows 下运行一个 shell 毕竟不能连接到一个真正的终端上。

当然，假设你有一个复合 USB 设备，你可以用它来做同样的事情。还假设你能找到一个工作的驱动程序，并让它工作。然而，许多微控制器都有一个串行端口，甚至是一个内置 USB 转换器的端口，但很少有完整的 USB 硬件。即使有，也经常与 PC 端的陌生驱动程序发生冲突。即使在最简单的微控制器上，串行端口也能正常工作。

## 这个计划

这个计划很简单。一个 Linux 程序监听一个真实的串行端口，并观察数据流中的特殊字符序列。这些序列将允许您交换数据，以便数据流将到达特定的终端。从终端返回的数据将在发送一个识别其来源的序列后进入真正的串行端口。

我构建了一个虚构的示例，因为我想要测试某些关键特性。在微控制器上，一个线程读取模拟量，另一个读取数字量。系统将这两者打印到单独的虚拟串行端口。如果您在任一终端中按键，相关数据将暂停。还有一个调试终端和一个命令终端，接受用户输入来改变数据采样的频率。

 [https://www.youtube.com/embed/qavE2vdpJug?version=3&rel=1&showsearch=0&showinfo=1&iv_load_policy=1&fs=1&hl=en-US&autohide=2&wmode=transparent](https://www.youtube.com/embed/qavE2vdpJug?version=3&rel=1&showsearch=0&showinfo=1&iv_load_policy=1&fs=1&hl=en-US&autohide=2&wmode=transparent)

T2】

顺便说一下，代码在 [GitHub](https://github.com/wd5gnr/SerialMux) 上。如果您没有使用带 Mbed 的 STM32F411 Blackpill，您可能需要做一些工作。但是，请记住，代码的复杂性是为了适应 Mbed 库。实际的协议很简单，您可以在任何地方实现它。

## 协议

说到协议，它既轻量级又健壮。每个设备既是发射器又是接收器，它们之间几乎没有联系。因此，当一个设备向虚拟通道发送数据时，它可能从完全不同的虚拟通道接收数据。每个虚拟频道都有一个范围从 0 到 253 的标识号。

发送器直接通过端口发送大部分数据字节。当需要更改虚拟端口时，发送器发送一个 FF 字节，后跟通道号。有几个问题需要考虑。

首先，发射机必须意识到，如果它真的想发送 FF，它不能。所以它发送 FF FE 来代替。如果你只发送 FF 字符，那么发送的数据量会翻倍，但这种情况相对较少。

第二，如果发送方发送 FF，然后死亡，则存在鲁棒性问题。下一个字节可以被认为是频道号。然而，由于新重启的发射机应该发送初始信道选择器，下一个字节应该是 FF(初始发射选择器)。为了解决这个问题，协议接受任意数量的 FF 字节作为合法前缀。因此，以下所有选项都将选择通道 4:

FF 04
FF FF 04
FF FF FF FF FF

[![](../Images/5c1dff0323417307def7dea9fe47ae64.png)](https://hackaday.com/wp-content/uploads/2022/04/funnel.png) 唯一的问题是串行连接是否断断续续。有可能得到一个 FF 字节，让电缆暂时断开，然后得到一个稍后的字节，这将触发不需要的频道改变。您对此无能为力，尽管这假设下一个字节是合法的通道号，因为大多数系统不会使用所有可能的通道。您可以通过超时转义前缀或给交换序列添加校验和来增加一些健壮性，但这只能减少问题，而不能消除问题。如果您处理的是纯 ASCII 数据，将通道限制在 0x80 以上会减少问题，但同样不能完全消除问题。在实践中，如果你有一个可靠的串行连接，没有问题。

第三种情况是接收者死亡，中途重新开始。这可能会导致一些数据进入错误的虚拟终端的问题。有两个特性对此有所帮助。首先，如果发射机向接收机发送 FF FD，接收机应该重新发送其当前的信道选择器。你也可以设置一个发送器定期发送频道选择器，因为多次发送同一个选择器是无害的。

部分解决这个问题的另一种方法是使用 Linux 服务器上的`-s`开关来阻止任何数据流向虚拟终端，直到明确选择了一个虚拟终端。请注意，这仅在服务器的启动阶段才重要。一旦选择了一个频道，它将保持选中状态，直到选择了另一个频道。

## 吻

[![](../Images/c2cedcc9b01e38e89eed0e98b36a0e24.png)](https://hackaday.com/wp-content/uploads/2022/04/sport.jpg) 你大概能看出来，这里所有的复杂都是让服务器端适应 Linux，微控制器端适应 C 库调用。如果你想从一个 Arduino 发送数据，简单的做法是在所有数据前加上前缀“\xFF\xCC ”,其中 CC 是频道号。接收数据可能就这么简单。你只需要记住你什么时候见过一个 FF，处理三个转义码(也就是说，FE 是一个真正的 FF，FD 是一个重新发送频道选择器的请求，其他的都是换频道)。

然而，我希望能够在电缆的两端都有虚拟串行端口，所以这需要更多的工作。部分原因是使用 Mbed I/O 流充其量也就是奇怪的事情。首先，让我们看看 Linux 服务器。

## Linux 服务器

Linux 软件打开一个终端端口(如`/dev/ttyUSB0`或`/dev/ttyACM0`等)。)然后产生多个大多数终端软件都能用的伪终端。对于 USB 设备，波特率可能并不重要。然而，对于一个真正的串行设备，你可能需要匹配波特率(未经测试)。代码目前不改变波特率，所以你需要在外部设置它或者修改代码。

ttymux 程序有几个选项。唯一重要的是-c 选项，它定义了一个虚拟端口。每个端口都有一个从 0 到 253 的 ID 号。你也可以要求一个符号链接。例如，看看这个命令:

```
ttymux -c 10 -c 33:virtualportA -c 50:/tmp/portB /dev/ttyACM0

```

在这里，我们创建了三个端口。端口#10 没有名称。端口 33 和 50 将在。/virtualportA 和/tmp/portB。

其他选项:

*   -d–退出时自动删除符号链接
*   -n–不要在串行端口上设置属性
*   -s–除非明确选择，否则不要向虚拟端口发送数据

当程序运行时，你会看到一个频道及其相关的伪终端的列表(可能是`/dev/pts/X`，其中 X 是某个数字)。如果您不提供符号链接，这就是您连接到虚拟端口的方式。如果你提供了一个符号链接，你可以使用任何一个。请注意，ID 号与 pts 号不同。所以上面例子中的通道 10 很可能不会是`/dev/pts/10`。如果是，那只是巧合。

要进行编译，您需要 pthreads:

```
g++ -o ttymux ttymux.cpp -lpthread
```

看一下[代码](https://github.com/wd5gnr/SerialMux/blob/main/linux/ttymux.cpp)，服务器实际上并没有那么复杂。有两个线程。一个读取串行端口，另一个写入串行端口。其他任何东西都不会触及真正的串口。那么每个虚拟频道都有它自己的 pty。不需要缓冲字符什么的。

创建 pty 的部分非常简单:

```

pty=posix_openpt(O_RDWR|O_NOCTTY|O_NONBLOCK);
if (pty==-1) return -1;
grantpt(pty);
unlockpt(pty);

```

要创建符号链接，您需要知道 pty 的名称，这就是 getptyname 调用的目的。使用该文件名打开将为您提供 pty 的终端侧。我通常使用 picocom，它没有问题。但是有些程序，比如 cutecom，太了解串口应该是什么样子了，所以你不能用它们打开 pty。

## 微控制器

微控制器代码有点复杂。这个 [SerialMux](https://github.com/wd5gnr/SerialMux/blob/main/blackpill-mbed-usbserial-mux/SerialMux.cpp) 类完成所有的工作。与 Linux 端一样，它有两个线程控制对真实端口的访问。与 Linux 端不同，每个虚拟串口对象都有自己的一组输入和输出缓冲区。线程填充这些缓冲区，并最终由`_read`和`_write`将数据读入 Mbed 流基类或从 Mbed 流基类中取出数据。这并不是非常高效，因为流最终会逐个字符地调用`_putch`和`_getch`来执行 I/O 操作，但是这是有原因的，如果你真的想调整它，你可以覆盖底层方法。

让我感到惊讶的一件事是，`isatty`函数返回 true 完全破坏了 I/O 系统。我不知道为什么，但我注意到工厂标准的 USBSerial 类对此也返回 false，并在 Mbed 源代码中有一个关于它的注释。

另一件奇怪的事情是，流的内置互斥体表现得很奇怪，我从来没有找出确切的原因。它可能保护所有的流或其他东西，但我最终恢复到用我自己的互斥体来保护每组缓冲区，用另一个互斥体来保护物理串行端口。

一旦你遵循了逻辑，SerialMux 类就没那么难了。main.cpp 中的许多代码都是为了解决 USB 端口断开时的问题。

我还复制并修改了一个我以前用来构建[命令处理系统](https://github.com/wd5gnr/cmdparse)的类。对于这个来说可能有点过了，但是我把它挂在身边，它很容易使用。有趣的是，代码对复用系统一无所知。它只需要一个正常的流，工作正常。

## 在使用中

一旦加载了微控制器程序，就可以使用以下命令行运行 Linux 服务器:

```
ttymux -s -c 1:analogport.virtual -c 2:digitalport.virtual -c 100:debugport.virtual -c 10:cmdport.virtual
```

然后，我在每个虚拟端口上使用 picocom，尽管您可能使用任何其他终端程序。为了您自己的利益，您需要为命令终端设置一些选项:

```
picocom -c --omap crlf cmdport.virtual
```

在模拟和数字终端中，按下除空格以外的任何键来暂停循环。将恢复一个空格。在命令窗口中，您可以使用 help 命令来获取您可以执行的操作的列表。不要指望退格键能起作用，尽管如果你想解决这个问题，有很多方法可以解决。

## 未来方向

该协议很简单，即使示例并不简单，而且可能有许多端口。即使简单的微控制器也可以模拟许多端口。

在服务器端，肯定会有人要求 Windows。看起来你可以用 com0com 或它的相关项目做类似的事情。其他的想法是提供网络套接字而不是伪终端，或者设计一个系统来复制假端口。协议和代码非常简单，足以让这一切成为可能。

的确，如果你有硬件和驱动程序支持，USB 复合设备是这个问题的一个更好的答案。然而，这需要更多的工作、更多的资源，并且限制了廉价硬件的参与能力。

如果你对 USB 路线感兴趣，如果你能提供自己的 Windows 驱动程序，这里有一些使用 Pi Zero 的例子和一些用户空间代码。如果网络角度引起了你的兴趣，你可以试试 [ser2net](https://hackaday.com/2021/02/11/linux-fu-serial-untethered/) 。