# 苹果落司

> 原文:[https://hackaday.com/2021/12/09/apple-falling-division/](https://hackaday.com/2021/12/09/apple-falling-division/)

赛格的[保罗·柯蒂斯]有一系列关于计算除法的有趣的博客文章。这曾经是一个比较热的话题，但是现在很多计算机或者计算机语言都内置了对乘除的支持。但是有些处理器缺少指令，而做这件事的库可能不够理想。知道如何滚动你自己的可能会让你优化速度或空间。本期包括使用牛顿算法做除法。

史蒂夫·马丁有一句关于如何成为百万富翁而不纳税的名言。他开始说，“首先……得到一百万美元。那么……”这种方法有点像，因为你首先要知道如何乘法，然后才能除法。基本前提有两个:牛顿的方法让你通过连续的乘法来精确估计倒数，然后将一个数乘以倒数等于除法。换句话说，如果我们需要把 34 除以 6，你可以把 34/6 改写成 34 * 1/6，答案是一样的。

牛顿的倒数近似值可以让你猜测答案，然后通过一系列乘法运算来完善它。每一次乘法都能提高精确度。您可以使用它来执行经典的速度/空间权衡。例如，让我们假设我们想找到一个字节(假定是一个定点字节)的倒数。256 个元素的查找表将提供完美的精度并且非常快。不再需要数学。但是 32 位呢？现在桌子太大了。但是你可以查找，比方说，32 位数的前 8 位。或者更多。或者更少。取决于什么对你来说是重要的。

所以现在你对你的倒数估计很差。伊萨克爵士可以做得更好。对于某个数字 *a* ，你把你的估计( *x* )和它们相乘。从 2 中减去这个数，你就有了一个因子，你的旧估计乘以这个因子就得到一个新的估计。跳过前面，很明显，如果你的估计是正确的，乘法会给你 1，这不会改变旧的估计。如果估计值是错的，你会得到一个比例因子。

作为一个公式，它看起来像这样:

```
x=x*(2-a*x);
```

因此，如果您决定 22 的倒数可能是 0.02，第一遍将会给出:

```
0.02*(2-22*0.02) = .0312

.0312*(2-22*.0312) = .0410

.0410*(2-22*.0410) = 0.0450
```

正确答案是一个重复的十进制数 0.0454545，如果你继续前进，你会到达那里。

当然，然后你还得再乘一次才能做除法。

我们喜欢这篇文章的定点实现，然后研究 ARM、RISC-V 和 dsPIC30 的汇编代码。很值得一读。

我们喜欢在汇编语言中使用的数学技巧。如果你正在做 AVR 和浮点，[不要错过这个方法](https://hackaday.com/2012/07/15/a-detailed-explanation-on-speeding-up-avr-division/)。