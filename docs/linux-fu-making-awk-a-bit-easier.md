# Linux-Fu:让 AWK 变得简单一点

> 原文：<https://hackaday.com/2020/09/29/linux-fu-making-awk-a-bit-easier/>

`awk`是一种用于文本文件的瑞士军刀。然而，它的一些限制往往有点烦人。我使用了一组简单的函数来使`awk`变得更好，尽管我要警告你:它确实需要对`awk`的 GNU 扩展。也就是必须用`gawk`而不能用其他版本。您的系统可能会将`/usr/bin/awk`映射到某个东西，而那个东西可能是`gawk`。但也可能是`mawk`或其他口味。如果你使用基于 Debian 的发行版，update-alternatives 是你的朋友。但是出于本文的目的，我将假设您使用的是`gawk`。

在这篇文章的最后，你将看到如何使用我的 [`awk`附加函数](https://github.com/wd5gnr/awkparse)将一行拆分成多个字段，即使没有单个字符来分隔所有字段。此外，您可以使用自己决定的名称来引用字段。您不必记住$2 是时间字段。你会说`Fields_fields["time"]`来代替。

## 问题是

当你用它来处理文本文件时，它能为你做很多普通的工作。它一次读取一个记录。通常，记录是单行。然后，它使用空格或其他字段分隔符来拆分字段上的行。您可以编写操作行或单个字段的代码。这个默认行为非常好，尤其是因为您可以更改记录字符的结尾和字段分隔符。符合这种格式的文件数量惊人。

当然，直到他们不知道。如果您有来自数据记录仪器或一些数据库的数据，它可以用多种方式格式化。一些字段可能具有带各种分隔符的结构化数据。这不是一个交易破坏者。因为你可以得到整行，你几乎可以做任何你想做的事情，但是逻辑更难，使用`awk`的目的是让事情更简单。

例如，假设您有一个来自数据记录器的文件，该文件有一个八位数的序列号，后跟一个六字符的标记，然后是两个由冒号分隔的浮点数。该模式可能看起来像

```

^([0-9]{8})([a-zA-Z0-9]{6})([-+.0-9]+),([-+.0-9]+)$

```

这很难用传统的字段分割来处理，通常你只需要编写代码来分割所有的部分。

如果您有常规字段，但不知道有多少，您可能想设置`FS`或`FPAT`。之前我们在[滥用`awk`读取十六进制文件](https://hackaday.com/2016/07/13/gawking-hex-files/)的时候，稍微谈过`FPAT`。这个图书馆有点不同。你可以用它完全拆开一条线。例如，您可能有一部分字段长度固定的行，然后有多种类型的分隔符。这可能很难用其他方法来处理。

## 正则表达式

[![](img/64e98b310ccc814664c5deb68dff73fd.png)](https://hackaday.com/wp-content/uploads/2016/06/gawking-text-blogview.jpg) 为了方便起见，我将`gawk` `match`函数打包。当然，这个功能存在于常规的`awk`中，但是`gawk`增加了一个扩展，使得事情变得更加容易。通常，该函数对字符串执行正则表达式匹配，并告诉您匹配从哪里开始，是否匹配，以及匹配了多少个字符。

使用`gawk`中的 GNU 扩展，您可以提供一个额外的数组参数。该数组将获得一些关于匹配的信息。特别是，数组的第 0 项将包含整个匹配。如果正则表达式包含括号中的子表达式，数组将包含这些子表达式，并按照括号的顺序进行编号。它还将包含开始和长度信息。

例如，如果您的正则表达式是`"^([0-9]+)([a-z]+)$"`，而您的输入字符串是`123abc`，那么数组将如下所示:

```

array[0] - 123abc
array[1] - 123
array[2] - abc
array[0start] - 1
array[0length] - 6
array[1start] - 1
array[1length] - 3
array[2start] - 4
array[2length] - 3

```

您甚至可以使用嵌套表达式，因此输入为 z1x 的`"^(([xyz])[0-9]+)([a-z]+)$"`给出了`array[1]=z1`、`array[2]=z`和`array[3]=x`。

## 理论与实践

理论上，这就是你所需要的。您可以编写一个正则表达式来挑选一行，解析它，然后使用数组访问各个部分。实际上，更好的做法是把所有事情都做好，这样就可以使用简单的名称来访问数据。

作为数据格式的一个例子，考虑这样一行:

```

11/10/2020 07:00 The Best of Bradbury, 14.95 *****

```

有美国格式的日期、24 小时格式的时间、项目名称、价格和从 1 到 5 颗星的评级，这些可能不存在。编写一个正则表达式来抓取每个字段有点复杂，但不是很难。有一种方法可以做到:

```

"^(([01][0-9])/([0-3][0-9])/(2[01][0-9][0-9]))[[:space:]]*(([0-2][0-9]):([0-5][0-9]))[[:space:]]+([^,]+),[[:space:]]*([0-9.]+)[[:space:]]*([*]{1,5})?[[:space:]]*$"

```

这有点拗口，但是很管用。请注意，每一项都在括号中，其中一些是嵌套的。所以日期是一个字段，但是月、日和年也是字段。

## 图书馆

一旦您在 [GitHub](https://github.com/wd5gnr/awkparse) 上获取了文件，您就可以将 fields_*函数放入您的代码中。您需要在 BEGIN 标签中做一些设置。然后使用 fields_process 处理每一行。这里有一个小例子(省略了函数):

```

BEGIN {
fields_setup("^(([01][0-9])/([0-3][0-9])/(2[01][0-9][0-9]))[[:space:]]*(([0-2][0-9]):([0-5][0-9]))[[:space:]]+([^,]+),     [[:space:]]*([0-9.]+)[[:space:]]*([*]{1,5})?[[:space:]]*$")
fields_setupN(1,"date")
fields_setupN(2,"month")
fields_setupN(3,"day")
fields_setupN(4,"year")
fields_setupN(5,"time")
fields_setupN(6,"hours")
fields_setupN(7,"minutes")
fields_setupN(8,"item")
fields_setupN(9,"price")
fields_setupN(10,"star")

}

{
v=fields_process()

... your code here...

}

```

在您的代码中，您可以编写如下内容:

```

cost=Fields_fields["price"] * 3

```

简单吧？如果不匹配，函数`fields_process`返回 false。如果您愿意，您仍然可以访问普通的`awk`字段，如$0 或$2。

## 里面的

这些额外的函数依赖于两件事:对`gawk` `match`函数的扩展和`awk`的关联数组机制。在过去，我已经将命名键添加到现有的匹配数组中，这样您就可以通过任何一种方式获取数据。然而，我已经修改了它，使匹配数组是本地的，因为我几乎从来没有真正想要的能力，然后你必须过滤掉额外的字段，如果你想转储整个数组。

以`^`开始正则表达式，以`$`结束正则表达式来锚定整个字符串通常是有用的。只是不要忘记正则表达式需要处理空白空间的消耗，就像这个例子一样。当您的字段可以包含空格时，这通常是一个好处，但是如果您无论如何都希望用空格来分隔字段，那么使用原始的解析方案可能会更好。

另一个技巧是在解析完第一个字段后获取“其余的行”。可以通过在正则表达式的末尾添加`"(.*)$"`来实现。只是不要忘了使用`fields_setupN`为它设置一个标签，以便稍后可以获取该值。

对这个库的一个简单扩展是将模式变成一个数组。处理功能可以依次尝试每个模式，直到有一个匹配。然后，它将返回匹配模式的索引，如果没有匹配，则返回 false。如果您有一个复杂的文件格式，这将允许您定义多种类型的行。您可能还想为每个字段设置不同的字段标签。

我滥用工具做事情已经有很长一段时间了，比如建造交叉装配器 T2。即便如此，我可能也不是最差的罪犯。