# 滥用 CPU 的加法器来优化位计数

> 原文:[https://hack aday . com/2019/06/19/滥用-a-CPU-加法器-优化-位计数/](https://hackaday.com/2019/06/19/abusing-a-cpus-adders-to-optimize-bit-counting/)

如果你喜欢对 C 代码和生成的汇编语言吹毛求疵——我们承认我们确实喜欢——你不应该错过[Scaramanga 的] [对所谓的 Kernighan 诡计](https://giannitedesco.github.io/2019/06/15/abusing-add.html)的分析。如果你没有听说过这个技巧，这是一种非常有效的计数方法。

像惠斯通电桥和许多其他东西一样，柯尼根诡计也是名不副实。布赖恩·克尼根使它出名，但实际上在他 1988 年写它之前，它在 1960 年首次出版，并在 1964 年再次出版。计算位数的最简单的方法是扫描每个位的位置，记录你遇到了多少个 1 位，但问题是，这需要对每个位进行循环。一个 64 位的字，无论包含什么，都需要 64 次循环。您可以通过移除找到的每个位并在字变为零时停止来做得稍微好一点，但是如果您测试的最后一个位被置位，这仍然可能需要 64 个周期。

使用这个技巧，您可以观察到 X & (X-1)将总是清除一个单词的最低有效位。尝试几个例子:

```
X     X-1     X&(X-1)
0001  0000    0000
0010  0001    0000
0011  0010    0010
1010  1001    1000
1100  1011    1000
1111  1110    1110

```

你大概可以看到这是怎么回事。通过计算 X&(X-1 ),你在每次循环迭代中清除一个位，你只需要遍历实际设置的位数。

这种事情是一种常见的面试问题，尽管正如[Scaramanga]指出的那样，编译器可能会优化这种情况，以使用特定的 CPU 操作，并获得更好的性能。例如，x86 体系结构上的 POPCNT 指令将在一条指令中完成所有工作。他还详细解释了为什么会这样。

当然，大多数软件并不需要运行得如此之快，以至于值得使用晦涩难懂的招数。但有时也有道理。这也是在面试中对逻辑和解决问题的一个很好的测试。

如果你喜欢这类东西，一定要去看看肖恩·安德森的广泛的比特黑客列表。它展示了几种不同的方法来计算位数，并以不同的折衷来完成其他常见和不常见的任务。例如，您可以专门创建一个 256 条目的查找表，并以每个字节一个循环的方式完成整个过程，速度很快，但内存利用率很低。总是有得有失。

玩 bit 有很多种方法，[特别是在 C 中](https://hackaday.com/2015/08/28/firmware-factory-bit-fields-vs-shift-and-mask/)。或者你可以使用[工具](https://hackaday.com/2018/11/06/bitbench-helps-parse-binary-data/)把东西切碎，如果你只是想分析它们的话。