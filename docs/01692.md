# Linux 富:厨房同步

> 原文:[https://hackaday.com/2019/01/10/linux-fu-the-kitchen-sync/](https://hackaday.com/2019/01/10/linux-fu-the-kitchen-sync/)

Linux 和类似操作系统的一大优点是它们是可配置的。如果你不喜欢某样东西，很有可能你可以通过某个文件中的几个条目轻松地改变它。例如，以 bash 为例——无论如何都是非常流行的 shell。如果您想要不同风格的命令行编辑，有一个选项。您希望 tab 键匹配文件时不区分大小写吗？另一种选择。通常，这些设置在您的主目录中的一个所谓的概要文件中，如`.bashrc`。

只要你坐在你的电脑前工作，这是很棒的。你可以随心所欲地定制你的`.bashrc`和其他文件，然后在一个你想要的环境中工作。问题是当你有很多电脑的时候。也许你有一台网络服务器、一台台式机、一台防火墙机和几十台 Raspberry Pi 电脑。你如何保持所有的配置相同？那么一旦它们是相同的，你如何使它们保持最新？

## 剥企鹅皮的方法不止一种

[![](../Images/76e84f185ac5073d74fdf6f8bcea8172.png)](https://hackaday.com/wp-content/uploads/2018/12/home.png) 其实有几种方法可以做到。因为配置通常在某种文件中，所以您可以使用任何类型的同步方法来完成这项工作，只需要一点点努力。例如，您可以将所有配置文件放在一个目录中，然后将指向它们的符号链接放在主目录中的正确位置，然后使用`rsync`来保持该目录的一致性。

如果您熟悉 Git，这是另一个可能的解决方案，其额外的好处是知道什么时候改变了什么。事实上，在早先一篇关于[Git](https://hackaday.com/2017/05/23/stupid-git-tricks/)的奇怪用法的文章中，我谈到了[我对这个问题的解决方案](https://github.com/wd5gnr/bashrc)使用了 Git。然而，我注意到[twpayne]最近发布了 [`chezmoi`](https://github.com/twpayne/chezmoi) ，这是另一个旨在处理这个问题的系统。它是用 Go 编写的，采用了与我的系统非常不同的方法。

## 特征

根据项目资源库，`chezmoi`提供了以下功能:

*   您将主目录中文件的期望状态描述为声明
*   您可以使用模板来生成实际的文件
*   安全，包括与 Bitwarden、LastPass 和一些本地密钥存储程序的集成
*   自动处理更新，因此您不会让系统处于“半状态”
*   跨多个操作系统移植
*   通知您的行动，并提供一个“演习”模式
*   快速并与您选择的版本控制系统配合使用

听起来不错。根据您的操作系统的不同，安装会有所不同，但是您可以在存储库中找到它。

## 在使用中

[![](../Images/53e8330bd21c95c8aab8f350de4cbaa2.png)](https://hackaday.com/wp-content/uploads/2018/12/redplus.png) 不出所料，这个双星被称为`chezmoi`。有几个键盘命令:

*   添加–将文件置于`chezmoi`控制之下
*   编辑–编辑文件
*   diff–查看哪些变更(如果有)处于待定状态
*   应用–应用待定的更改

当您将文件添加到系统中时，它会将该文件的副本放在`~/.local/share/chezmoi`中。为了与版本控制兼容，`chezmoi`会忽略那个目录下的点文件，所以如果你添加一个类似`.bashrc`的文件，系统会自动将其重命名为`dot_bashrc`。

如果这就是全部，那就没什么特别令人兴奋的了。这里唯一真正的技巧是同步副本，而`chezmoi`使用外部版本控制系统来做这件事。但是，当您需要不同机器上的一些唯一文件时，会发生什么情况呢？

## 独特的雪花

[![](../Images/5cd65c9f538d07492311513e0a8796ac.png)](https://hackaday.com/wp-content/uploads/2018/12/snow.png) 例如，假设在你的桌面机上你想使用一个独特的提示。在服务器、防火墙和 Raspberry Pi 机器上，您只需要一个简单的提示。这意味着每台机器都必须在`.bashrc`中有自己的`PS1`字符串。

您可以通过在`chezmoi.yaml`文件的数据段中定义条目来做到这一点。实际上，您也可以使用 JSON、TOML 或其他一些格式。该文件在每台机器上都是唯一的，允许您替换到模板文件中。因此，我的桌面的 YAML 文件可能有一个针对`PS1String`的数据条目，它包含一个复杂的桌面提示，而 Raspberry Pi 的文件可能有一个简单的条目。

要添加一个文件(如`.bashrc`)作为模板，使用`add`命令的`-T`选项。模板会把`.bashrc`变成`dot_bashrc.tmpl`。由于 Go 的标准模板机制，您可以使用许多选项，`chezmoi`提供了描述计算机主机名、操作系统、架构和用户名等内容的变量。

因为有了模板语言，你不仅仅需要使用自定义变量。您也可以在模板中创建条件节。例如，您可以这样写:

```

# common config
export EDITOR=vi

# machine-specific configuration
{{- if eq .chezmoi.hostname &quot;work-laptop&quot; }}
# this will only be included in ~/&lt;code&gt;.bashrc&lt;/code&gt; on work-laptop
{{- end }}

```

## 安全性

`Chezmoi`还识别具有私有文件系统权限的文件，并采取相应的措施。`chezmoi`目录是私有的，它会用一个`private_`文件名前缀(例如`private_dot_bashrc`)来标记应该是私有的文件。

[![](../Images/a700858352a879eb65c86ffb01c85e88.png)](https://hackaday.com/wp-content/uploads/2018/12/security.png) 想必，你会使用一些版本控制系统来处理同步。换句话说，当设置或更新一台机器时，您应该将您的`chezmoi`目录与版本控制副本进行协调，然后在配置文件中设置任何内容并应用任何更改，可能是在验证了有什么更改之后。

当然，这意味着你存储的文件将和你的版本控制系统一样私有。如果你把你的配置文件发布到一个公共主机上，那么事情就暴露了。对此的一个答案是使用模板系统，不要对配置文件进行版本控制——因为它在每台机器上都是唯一的，所以无论如何都不应该在版本控制中，这也意味着您需要以另一种方式备份它。

例如，在配置中可能有:

```
hackaday:

   password: 0xdeadbeef
```

这应该是私人的。那么在可能公开的文件中你会有:

```
password = {{ .hackaday.password }}
```

还有一个使用`gpg`加密配置文件的选项。

## 版本控制

说到版本控制，系统有一些命令为支持的版本控制系统做推和拉。默认值是`git`，但是您可以在配置文件中更改为其他选项，例如`hg`。

还有一些命令可以获取一整套配置文件或导出配置。您可以在项目的资源库中阅读所有这些命令。默认情况下，一切都在您的主目录下工作，但是如果您愿意，您可以指定其他目标目录。

## 管理

总的来说，这个项目似乎考虑得很周全，但是我没有看到一个令人信服的理由来改变我的系统。不过，如果我在思考这个问题的时候，它就在我身边，我可能会用它，而不是用我自己的。我同意模板系统是强大的，但是我的系统通过根据环境选择不同的文件得到了类似的效果。

`chezmoi`中的唯一数据文件在版本控制中很难处理。您可能根本不想对该文件进行版本控制。如果您的存储库是私有的，或者您禁止在配置文件中包含私有信息，那么您可以对数据文件的示例(即 Raspberry Pi vs desktop)进行版本控制，然后作为安装的一部分，您可以重命名示例文件。但是，更有可能的是，您只是复制现有系统的配置。但是，它也有好处，如果设置正确，您可以安全地使用公共存储库。

我的系统真的想要一个私有的存储库，除非你不在乎发布你的配置文件。然而，所有的文件都在版本控制之下，系统可以计算出文件的位置，不需要学习复杂的模板系统。你只需要把东西放在正确的文件里。基于对`chezmoi`的观察，我可能添加到我的系统中的唯一特性是添加特性，因为我也提供了同步其他配置文件的方法，但是现在你必须手动设置它。这一步相当于将它移动到一个目录中，在文件中添加一行，并创建一个符号链接。

但是这就是 Linux 的好处。做事情有很多方法，如果你不喜欢一种方法，你可以找到另一种方法。如果你不喜欢任何一种选择，也可以很容易地创建自己的解决方案。在某种程度上，对于大多数正常人来说，这就是 Linux 的问题。他们不想在众多选择中挑选。我们只是碰巧在一个喜欢争论诸如 emacs vs vi、C vs Python 之类的事情的社区中。