# 本周在安全:模糊修复，犯规字体，TPM 定时攻击，等等！

> 原文:[https://hack aday . com/2019/11/15/this-week-in-security-fuzzing-fixes-foul-fonts-TPM-timing-attacks-and-more/](https://hackaday.com/2019/11/15/this-week-in-security-fuzzing-fixes-foul-fonts-tpm-timing-attacks-and-more/)

通过谷歌的 ClusterFuzz 项目，在`libarchive` [发现了一个问题。`Libarchive`是一个压缩和解压缩库，在实用程序中广泛使用。这里的问题是库如何从畸形的归档中恢复。命中无效的头会导致正在使用的内存被释放。问题是，即使在工作内存被释放后，文件处理仍有可能继续，从而导致各种问题。到目前为止，一个实际的漏洞还没有被披露，但它很可能是可能的。](https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=14689)[这个问题在五月份就被修复了，但是这个问题只是为了给用户时间来更新。](https://github.com/libarchive/libarchive/commit/b8592ecba2f9e451e1f5cb7ab6dcee8b8e7b3f60)

值得注意的是，这个问题是通过谷歌的模糊努力发现的。谷歌运行了 oss-fuzz 项目，该项目自动从大约 200 个开源项目中获取夜间版本，并对其运行 ClusterFuzz。这个向程序和函数扔随机数据的过程已经暴露了超过 14，000 个错误。
T3】

### PDF 文档和嵌入字体

Adobe 最近发布了针对 Reader 的安全更新[。本次更新中有一堆漏洞，但引起我注意的是](https://helpx.adobe.com/security/products/acrobat/apsb19-49.html) [CVE-2019-8196](https://bugs.chromium.org/p/project-zero/issues/detail?id=1927) 。这也是通过 fuzzing 发现的，虽然在这种情况下，它是随机操作一个有效的 PDF 文档，产生了格式错误的文件。对嵌入字体的更改导致从未初始化的内存位置读取。令人担忧的是，经过近十年的字体相关漏洞，像这样的崩溃仍然是可能的。

### 可信平台模块计时攻击

可信平台模块是嵌入在许多主板上的一个硬件，允许卸载加密操作。在这种情况下，将签名和加密等任务从 CPU 上移走的目的不是为了提高速度。相反，TPM 旨在成为一个受信任的平台，即使操作系统已经受损。一项名为 [TPM Fail](http://tpm.fail/) 的新研究展示了一种计时攻击，这种攻击揭示了 TPM 中嵌入的一个密钥。

计时攻击颠覆了正常的编程范式。例如，当使用`grep`在一个大文件中查找一个字符串的第一个实例时，您希望操作尽可能快地完成。如果你要搜索的数据出现在文件的前 10%,很明显，搜索程序应该停止搜索，一旦找到就返回一个答案。不太明显的是`grep`发现你的模式所花费的时间泄露的信息。想象一下，在同一个文件上运行几个这样的搜索，都在寻找不同的字符串。给定时间数据和源文件，就有可能对搜索字符串做出有根据的猜测。

现实世界中的一个典型例子是字符串比较例程。如果两个字符串的第一个字符不同，例程可以立即返回，但是如果前 10 个字符相同，并且字符串直到第 11 个字符才分开，则该例程将花费长得多的时间来运行比较。如果有足够的时间观察比较，攻击者可以一次一个字符地算出秘密字符串。比较时间越长，正确的字符越多。解决这一难题的标准方法是使用常数时间函数。在我们的字符串比较示例中，这意味着比较字符串的每个字符，不管它们有多么不同。

有问题的研究人员发现，在执行椭圆曲线例程时，某些 TPM 2.0 实现无法使用常数时间算法。那么结果有多糟糕呢？在易受攻击的系统上，假定攻击者可以在该机器上运行代码，秘密 TPM 密钥最多可以在 20 分钟内被提取出来。更糟糕的是，在由 TPM 支持的 VPN(如 StrongSwan)的情况下，可以在 5 小时的网络流量中提取密钥。

软件实现可以打补丁，但硬件 TPM 很难修复，因为它们在设计上不是可闪存的。密钥如何映射到时间变化的数学有点复杂，但是[都在论文](http://tpm.fail/tpmfail.pdf)中，所以去看看吧。

### 僵尸之地起死回生

考虑到这个名字，[僵尸王以僵尸王 V2 的形式再次崛起](https://zombieloadattack.com/)。这次的问题是现代英特尔处理器中的事务同步扩展(TSX)。现有的缓解措施不足以防止 TSX 异步中止(TAA)漏洞，所以这次攻击没有与 Zombieload 的其余细节一起披露。让 TAA 特别成问题的是，一个进程不需要使用 TSX 指令，攻击者所需要的只是访问它们。对于易受攻击的处理器，最终的解决方案是完全禁用 TSX 指令。 [Linux 内核文档](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/diff/Documentation/admin-guide/hw-vuln/tsx_async_abort.rst?id=eb094f06963bb0fd8134c6a9b805d4ad0002a7d4)中有一些我发现的最有用的信息。

### Windows 攻击

最近曝光了两起针对 Windows 系统的攻击。首先是[幽灵土豆](https://shenaniganslabs.io/2019/11/12/Ghost-Potato.html)，一个 NTLM 反射攻击。NTLM 是内置于 Windows 中的身份验证解决方案。多年来，针对 NTLM 的攻击层出不穷，针对这些攻击的缓解措施也层出不穷。Windows 关闭源代码的一个副作用是，并不总是清楚这些缓解措施到底是如何工作的。Ghost Potato 就是一个例子，说明一旦攻击者了解这些缓解措施的工作原理，就可以轻松地绕过它们。

NTLM 反射攻击的本质是，如果攻击者能够诱骗用户尝试使用恶意机器执行 NTLM 身份验证。然后，在连接的机器上实时重放该身份验证，实际上是让受害者用自己的机器进行身份验证。一旦身份验证完成，攻击者就可以接管会话并充当经过身份验证的用户。减轻这种攻击的方法之一是记录加密挑战。将传入的质询消息与最近发送的消息进行比较，冲突可能是一种攻击。问题在于挑战从缓存中过时的速度有多快:5 分钟。可以将 NTLM 身份验证会话延长到 5 分钟以上。此时，发送第二次伪连接尝试将把目标消息推离缓存的末端，反射尝试将会成功。它很聪明，并且在 11 月的周二更新中得到了修复。

Bitlocker 是一种磁盘/文件夹加密解决方案，自从 Windows Vista 问世以来，它就已经融入到 Windows 中。一组研究人员刚刚发表了一篇论文，详细介绍了应用于 Bitlocker 的最先进的密码破解技术。他们的 [Bitcracker 程序](https://github.com/e-ago/bitcracker)包含了一些新颖的性能改进。首先，他们意识到 Bitlocker 解密算法的一部分可以部分预先计算。建立了一个 256 Mb 的查找表，减少了每次密码尝试的时间。

第二个改进是在进行所有通常需要的计算之前，快速确定解密尝试是否成功。Bitlocker 解密通常以计算和比较消息身份验证代码结束。如果计算出的 MAC 与预期相符，则密码是正确的。人们注意到，适当解密的输出在不计算 MAC 的情况下是可识别的。本质上，他们能够快速确定给定密码尝试的结果是否给出了合理的输出，而无需完成该过程。这种捷径可能会导致一些误报，但误报的数量很低，足以使这种方法非常值得努力。

当使用支持 CUDA 的高端 GPU 时，他们能够在一天内测试超过 1 亿个密码。这种性能不足以暴力破解一个好的密码，但肯定会使大型字典攻击变得微不足道。他们的结论是，使用不在密码列表中的好密码仍然很重要。