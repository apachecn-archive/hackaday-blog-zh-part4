# 了解使图像存在于内存中的位和字节

> 原文:[https://hack aday . com/2021/08/05/known-the-bit-and-bytes-make-images-live-in-memory/](https://hackaday.com/2021/08/05/knowing-the-bits-and-bytes-that-make-images-live-in-memory/)

我们知道我们生活在未来，因为我们看到的每一个高密度屏幕上都有高分辨率的全彩色图像。当然，这是有代价的，这种代价被无数的改进所掩盖，这些改进体现在我们以数字方式表现那些漂亮的像素，以及我们如何把它们推上屏幕。没有人会想到这一点，除了那些在屏幕后面存储和点亮这些像素的人。嘿，有可能有一天你也会这样。是时候学习更多关于图像编码的知识了！

[![](../Images/94433b4deb2eadc6d4a7f732e6b60602.png)](https://hackaday.com/wp-content/uploads/2021/08/sw-harding-represent-images-in-memory-benchmark-thumb.jpg)

Test renders illustrate the time savings from premultiplied alpha formats

[斯科特·W·哈登]整理了一本关于在记忆中表现图像的简明入门书。它着重于图像如何存储的基础:通常在 G 之前有 B，有时包括 alpha(透明)通道，并有许多不同的位深度。对于微控制器项目来说，首先考虑这些因素至关重要，因为决定支持哪种类型的图像通常会受到帧缓冲区可用内存量的限制，以及被选作器件显示屏的屏幕的能力。

说到显示器细节，[Scott]分享了一些关于将内存映射到屏幕尺寸的细节。如果像素数据的字节数与屏幕尺寸不匹配，填充这些行可能有助于减少将这些像素显示在屏幕上所需的处理开销。他也有一些关于“预乘 alpha”的技巧，这使得透明度计算成为图像本身的一部分，而不是在试图更新屏幕时要求这样做。用 C#在一百万帧渲染上运行一个测试显示了你可以预期的节省类型。

几十年的反复试验使我们有了这些方案。回顾实际上是一个考古项目，一名黑客在试图从一家 20 世纪 90 年代的照片处理服务公司的软盘上获取一组数字图像时发现了这一点。