# 用一条指令来控制它们:C 编译器只发出 MOV

> 原文:[https://hack aday . com/2021/05/21/one-instruction-to-rule-them-all-c-compiler-emisses-only-mov/](https://hackaday.com/2021/05/21/one-instruction-to-rule-them-all-c-compiler-emits-only-mov/)

成功编译 C 代码需要多少条指令？让我们看看，你需要一些跳转指令，一些算术函数，当然，还有移动指令，对吗？原来你[只需要移动指令](https://github.com/Battelle/movfuscator)，至少在 x86 上是图灵完整的。

虽然这种努力有点开玩笑，但我们不得不承认，如果你试图创建自己的 CPU，这将有助于一个简单的架构，并可能具有强大的功能或复杂性优势，所以也许有人会发现它的实际用途。如果您想要一个简单 CPU 的 C 编译器，这也不需要在字节码级别进行太多的模拟。

它是如何工作的？回答这个问题的最好方法是看看 GItHub 网站上的演示幻灯片。一切都是通过巧妙使用内存位置和虚拟地址来实现的。高效？也许不是。但它确实有效。

例如，如果你想测试 x 和 y 是否相等

```

    mov [x],0
    mov [y],1
    mov R,[x]

```

当然，这隐藏了很多细节，但是这个想法是，如果 Y 不等于 X，你将写一个 1 到某个随机存储器位置(这最好不重要；这是细节之一)。如果 X 和 Y 相等，你会用 1 覆盖。所以如果 X 和 Y 不同，R 的结果是 0，如果相同，R 的结果是 1。

实际上，如果你想翻译像“if (x==y) x=100”这样的东西，你可以使用上面的技巧设置一个指向 X 或者一个虚拟位置的整数指针(只需用 X 的地址代替 1，用虚拟地址代替 0)。然后将 100 存储到这个整数指针中。如果没有分支，每行代码都会执行。

然而，事实上，编译器做出了一些妥协，包括使用跳转来调用外部函数和浮点指令。您可以通过重新编译库和添加仅支持 MOV 的浮点仿真器来避免这两种情况，这很有趣，但可能性能不是很好。

这让我们想起了过去见过的几台[“单指令”计算机](https://hackaday.com/2020/08/13/pic32-dma-is-a-weird-machine/)(包括我的)。虽然这是一个有点奇怪的编译器目标，但它几乎不是我们见过的最奇怪的。