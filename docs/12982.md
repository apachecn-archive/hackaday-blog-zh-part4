# 现代的 CPU 比你想象的要聪明

> 原文:[https://hack aday . com/2022/03/09/modern-CPU 比你想象的要聪明/](https://hackaday.com/2022/03/09/modern-cpus-are-smarter-than-you-might-realize/)

当谈到编程时，我们大多数人都在抽象层次上编写代码，这可能是针对 20 世纪 60 年代的计算机的。输入进来，你处理它，然后产生输出。当然，调用`strcpy`在现代 CPU 上可能比在旧 CPU 上工作得更好，但是你的基本算法是相同的。但是，如果有办法定义你的程序在现代硬件上运行得更好呢？这是谢尔盖·斯洛廷的一本预印本的答案。

举个简单的例子，考虑分支对流水线的影响。几乎所有的现代计算机都在流水线上。也就是说，一个指令正在获取数据，而一个更老的指令正在计算一些东西，而一个更老的指令正在存储它的结果。当您已经部分执行了一条指令，并且意识到前面的指令导致了到代码另一部分的分支时，问题就出现了。现在，管道必须收回，当管道重新填充时，性能会受到影响。任何有影响的东西都必须逆转，其他的东西都必须抛弃。

[![](../Images/167cea4e24b0d383acfabadc9c1bda27.png)](https://hackaday.com/wp-content/uploads/2022/03/cpusmarts_detail.png) 这对表现不好。正因为如此，一些 CPU 试图预测分支是否可能发生，然后推测性地为预测的情况填充流水线。但是，您可以对代码进行结构化，例如，以便更明显地显示分支将如何发生，或者对于某些编译器来说，显式地通知编译器分支是否可能发生。

如您所料，像这样的技术依赖于您的 CPU，您需要进行基准测试来显示实际发生了什么。文本中充满了执行时间的图表和对生成的 x86 汇编代码的分析，以解释结果。即使你认为是一个非常好的算法——比如二分搜索法，在现代架构上也有问题，你可以用一些技巧来提高它的性能。实际上，有趣的是，这些技巧在 GCC 上有效，但在 Clang 上没有什么区别。还是那句话，你必须衡量这些东西。

可能我们中 90%的人永远不需要使用你在本书中找到的任何一种优化。但是如果你喜欢解谜和分析复杂的细节，这是一本了不起的书。当然，如果您需要从循环中挤出这些额外的微秒，或者您正在编写一个重视性能的库，这可能正是您正在寻找的书。虽然它没有涵盖许多不同的 CPU，但这些思想和技术将适用于许多现代 CPU 架构。如果你使用不同的 CPU，你需要做的就是弄清楚如何使用。

我们以前看过这类东西的片段。[流水线作业](https://hackaday.com/2018/06/12/real-world-pipelining-for-fpgas/)比如。不过，有时候优化你的[算法](https://hackaday.com/2019/01/06/software-it-is-all-in-the-details/)不如换一个更好的更有效。