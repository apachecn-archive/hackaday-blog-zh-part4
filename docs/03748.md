# 工作真正完成的地方——随意剖析

> 原文：<https://hackaday.com/2019/07/29/where-the-work-is-really-done-casual-profiling/>

一旦一个程序被调试并正常运行，可能就该开始优化它了。一种常见的方法是一种称为分析的方法，即观察程序执行并计算程序中每一步的计算时间。这对于大多数程序来说都很好，但是当进程在多个内核上执行时就变得复杂了。分析器可能会计算程序中等待另一个内核中的进程完成所花费的时间，从而给出无意义的结果。为了解决这个问题，开发了一种称为偶然剖析的方法。

在临时分析中，标记放在代码中，分析器可以测量程序到达这些标记的速度。由于涉及到多个内核，并且分析器无法加速程序的其余部分，因此它实际上会减慢所有其他部分的速度，并测量标记以模拟速度的增加。[Daniel Morsig] [采用了这一想法，并在 Go](https://morsmachine.dk/causalprof) 中实施，用一个例子来证明其有效性，将单个流程加速 95%，使整个程序增加 22%。使用一个常规的剖析器只能计算出 3%的增长，这还不如临时剖析器的 22%的测量结果信息量大。

我们从[Greg Kennedy]那里得到了这个提示，他说他在学术界之外很少使用临时分析，但是我们同意这种跟踪多线程程序效率的方法可能有一些用处。如果你知道任何其他解决这个问题的方法，或者看到因果分析在野外使用，请在下面的评论中告诉我们。

标题图片:阿兰洛伦佐[ [CC BY-SA 3.0](https://commons.wikimedia.org/wiki/File:Intel_Core_I7-920_Boxed_-_14.JPG) 。