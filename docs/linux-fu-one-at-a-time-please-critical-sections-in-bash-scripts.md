# Linux-Fu:请一次一个！Bash 脚本中的关键部分

> 原文：<https://hackaday.com/2020/08/18/linux-fu-one-at-a-time-please-critical-sections-in-bash-scripts/>

你通常会认为临界区是一种非常高级的技术，也就是说，它是一个程序的一部分，阻止其他程序使用资源。您当然不会经常认为它们是 shell 脚本的一部分，但事实证明它们对某些脚本非常有用。最常见的情况是，临界区保护一些系统资源，比如共享内存位置，但是也有 shell 脚本需要类似保护的情况。幸运的是，向 shell 脚本添加关键部分非常容易，我将向您展示如何添加。

## 有时候剧本需要自私

一个非常常见的情况是，您希望脚本只运行一次。如果相同的脚本在原始脚本处于活动状态时再次运行，您可能希望在打印一条消息后退出。另一种常见的情况是，当您正在更新某个文件时，您需要在进行更改时不受干扰地访问。

这实际上是一个让我思考这个问题的案例。我有一个脚本——可能是未来 Linux-Fu 的主题——它通过修改 DNS 服务器的配置文件来提供动态 DNS。如果脚本的两个副本同时运行，重要的是只有其中一个副本进行修改。第二个拷贝可以在第一个拷贝完全完成后运行。

## 原子文件

这个问题是原子性的问题。例如，您可以用模糊的名称创建一个临时文件，并确保该文件不存在。但是如果其他人同时检查呢？你们都注意到文件不在那里，然后你们都创建了文件，认为你们是单独运行的。不好。

文件是一个可能的答案，但是使用`flock`锁定文件才是正确的方法。这里有两个通用选项:调用`flock`为您执行一个命令，它将获取锁并在命令完成时释放它，或者您可以在自己的脚本中使用`flock`来保护代码块。

## 简单的例子

`flock`背后的想法是它会给一个文件加锁。文件可以打开进行读写，这并不重要。您可以获得一个共享锁，或者(默认情况下)请求一个独占锁。如果文件上没有其他锁，您只能获得一个排他锁。

你用什么文件？看情况。对于一个脚本，有时使用脚本文件本身作为锁是值得的。这当然使它明确，虽然如果有人复制脚本到一个新的名字，了望。另一个答案是使用临时文件。大多数系统都有`/var/lock`目录用于这个目的。

考虑这样一种情况，您有一个处理文件的脚本。脚本的一个选项是删除文件，但是如果文件的另一个实例正在使用它，您不希望这样做。您可能会这样做:

```
flock "$0"  rm "$SHAREDFILE"
```

这会获得一个独占锁。脚本的其他部分可能如下所示:

```
flock -s "$0" awk -f script.awk "$SHAREDFILE"
```

s 表示锁是共享的，所以其他任何请求共享锁的人都会得到它，但是 rm 的独占锁将一直阻塞，直到文件——在本例中是 shell 脚本本身——被解锁。

## 解除封锁

当然，有时候你不想永远等下去。您可以使用-n 选项告诉`flock`不要阻塞。或者使用-w 等待指定的秒数(不必是整数)。默认情况下，如果锁不起作用，`flock`将返回 1，但是您可以通过使用-E 来选择不同的代码，因为您运行的命令也可能出于某种原因返回 1。

## 临界截面块

有时您不想运行一个命令。您想要锁定脚本的整个部分。你也可以这么做。`flock`命令可以接受数字文件描述符。文件可以打开进行读写，但它必须存在。当然，如果您使用脚本文件，那么它肯定是存在的。

您可以使用所有相同的阻塞和超时选项，并且必须使用 bash 构造打开一个文件描述符。有几种方法可以做到这一点——我已经把[做成了例子](https://github.com/wd5gnr/shellcs)的报告，我将在下面引用它——但是我通常只在 subshell 中使用重定向。你也可以用`exec`得到同样的效果。

看看[这个剧本](https://github.com/wd5gnr/shellcs/blob/master/cs0.sh)。它有点做作，但是它准备了一个日志文件，然后调用自己两次，在该日志文件中创建两个不同的条目。没有保护日志的关键部分，所以在脚本完成后，您将看到两个子流程的输出是如何混合在一起的。

您可以使用简单的方法，只需在调用子进程之前让`flock`锁定脚本文件。这就是 cs.sh 中你可以[在这里](https://github.com/wd5gnr/shellcs/blob/master/cs.sh)看到的方法。然而，在这样的脚本中，使用带有数字文件句柄的块通常更有效。这里是[使用`flock`](https://github.com/wd5gnr/shellcs/blob/master/cs1.sh) 样式的同一个例子。子流程如下所示:

```

( flock 99 
echo Here is a log entry from A along with a directory of /etc >>"$LOGFILE"
ls /etc >>"$LOGFILE"
echo That is all from A >>"$LOGFILE" ) 99<"$LOCKFILE"
exit 0

```

当然，这是一个很傻的例子。在这种情况下，运行进程 A，等待它完成，然后运行进程 b 也同样容易。但情况并非总是如此，在复杂的脚本中，您可能有两个进程可以并行执行的工作，只需等待特定的关键部分。在这种情况下，连续运行流程会降低效率。

## 一个

临界区块的一个非常常见的用例是阻止脚本在任何给定时间运行多个实例。

```

#!/bin/bash
LOCKFILE="$0"
( if flock -n 99
then
  echo Running task
  sleep 20
  echo Done
  exit 0
else
  echo You can only run one copy of this script at a time!
  exit 1
fi ) 99<$LOCKFILE"

```

如果您有一个计划使用 cron 之类的东西定期运行的程序，那么这种模式非常有用。您可能每分钟都运行它，但是，有时，程序可能需要一分钟以上才能完成。群集屏障可以防止大量副本同时运行。

在所有这些情况下，文件关闭会自动释放锁，因此您不必显式释放锁。如果您确实需要提前释放它，那么-u 选项是您的好朋友。

## 几个音符

原来`flock`不是 POSIX 标准的一部分，但是它很常见。Linux 内核 2.6 之前。12，`flock`在 NFS 上空也没有正常工作。如果您使用/var/lock 或/tmp，无论如何，它们不太可能是 NFS 挂载的。如果出于某种原因，您在一个没有`flock`的系统上，mkdir 不能保证是原子的，但它通常是原子的，所以这可能是另一个选项，因为它也返回一个状态，如果它创建了一个目录或没有。

这种锁定技术不是你每天都需要的。但是当你确实需要它的时候，它是无价的。

一次处理一件事情的对立面是[并行处理](https://hackaday.com/2020/06/29/linux-fu-parallel-universe/)。你通常不需要解锁一个锁定的文件，因为当文件关闭时`flock`会处理好，但是如果你想超级防御，也许可以考虑使用[陷阱](https://hackaday.com/2019/08/26/linux-fu-its-a-trap/)清理任何需要清理的东西。