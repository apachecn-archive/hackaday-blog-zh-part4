# Linux Fu:向 Exec 学习

> 原文:[https://hack aday . com/2019/12/30/Linux-fu-leaning-down-with-exec/](https://hackaday.com/2019/12/30/linux-fu-leaning-down-with-exec/)

Shell 脚本很方便，使用 bash 这样的 shell 也非常有用。然而，shell 脚本并不总是非常有效。想想吧。如果你运行`grep`或`tr`或`sort`在一个 shell 脚本中做一些操作，你正在产生一个全新的进程。这需要时间和资源。但是有一些方法可以减少——但不能消除——这个问题。

你写过这样的程序吗(用任何语言，但我会用 C):

```

int foo(void)
{
  ...
  bar();

}

```

你希望编译器不要这样写汇编代码:

```

_foo: 
....

      call _bar
      ret

```

大多数优化器应该意识到这样一个事实，即您可以将这样的调用转换为跳转，并让 _bar 中的 ret 语句返回到 foo 的调用者。然而，shell 脚本并没有那么聪明。如果您有一个名为 MungeData 的 shell 脚本，它在最后一行调用另一个名为 PostProcess 的程序或 shell 脚本，那么您将同时有三个进程在运行:您的原始 shell、运行 MungeData 的 shell，以及运行脚本的 PostProcess 程序或 shell。更不用说，在 post 过程里面做事情的过程了。那你是做什么的？

## 输入 Exec

对此有几种可能的答案，但是在一个 shell 脚本最后调用另一个程序或脚本的特殊情况下，答案很简单。使用 exec:

```

#!/bin/bash
# Do stuff here
...
# Almost done
exec PostProcess

```

这告诉 shell 重用当前进程进行后处理。exec 之后出现的任何内容都不会运行，因为当前进程已被清除。当后处理完成时，调用我们脚本的原始进程将继续。这与 c 语言中跳转优化的调用/ret 非常相似。

## 内置

如果你看 bash 手册，有些东西是内置的，有些不是。使用内置程序应该比生成一个新程序要快。例如，考虑这样一行:

```

if [ $a == $b ]

```

一些 shells 使用名为“test”的程序来处理方括号。这将启动一个新程序。现代 bash 提供了这种内置功能，有助于加快脚本执行速度，使其更加高效。但是，如果您想对差异进行基准测试，可以禁用它。一般来说，您可以使用“enable -n XXX”来禁用内置，其中 XXX 是您想要禁用的内置。不要使用任何选项来启用它。如果您愿意，只需输入不带任何参数的命令就可以得到一个内置命令列表，或者使用-p 选项。

[![](../Images/b7a7c83795f8eae6a777bc4578cb8652.png)](https://hackaday.com/wp-content/uploads/2019/11/fig1.png) 然而，事情远不止如此。如果您有一些需要大量开销的常见操作，您可以用 C 之类的语言编写代码，并要求 shell 将其作为共享对象加载，然后将其视为内置对象。技术有点复杂，但它显示了外壳的多功能性。在本文中，您可以找到一个为 bash [添加一些内置命令的例子。例如，发布的代码使`cat`和`tee`成为 shell 的一部分，并创建新的命令。](https://www.drdobbs.com/shell-corner-bash-dynamically-loadable-b/199102950)

## 奇特的解决方案

我们承认，最后一个解决方案有点奇怪。然而，你还可以做其他的事情。您可以创建一个持久服务器，并使用命名管道与它进行通信，以避免运行新代码。当磁盘运行缓慢时，您可以尝试将经常使用的程序保存在 RAM 磁盘上。今天，缓存应该几乎自动地做到这一点，但也许不是在每种情况下。

有时仅仅清理你的代码会有所帮助。想象一下:

```

cat "$1" | grep "$target"

```

[![](../Images/9aa41d0bb396181c2a3869de3fc940dd.png)T2】](https://hackaday.com/wp-content/uploads/2019/11/fig2.png)

这产生了两个进程，一个用于 cat，一个用于 grep。为什么不直接说:

```

grep "$target" "$1"

```

当然，最终的结果是不使用 shell 脚本。几乎任何编程语言都有更丰富的功能，无需启动外部程序。编译或半编译语言可能会更快，甚至会帮助你优化。

Shell 脚本在某种程度上是有用的。看看你能把它们拉伸到什么程度也很有趣。然而，如果你真的担心效率或速度，这可能是最好的答案。