# 本周安全:DDoS 技术、脏管道和 Lapsus$继续

> 原文:[https://hack aday . com/2022/03/11/this-week-in-security-DDOS-techniques-dirty-pipe-and-lapsus-continued/](https://hackaday.com/2022/03/11/this-week-in-security-ddos-techniques-dirty-pipe-and-lapsus-continued/)

拒绝服务(DoS)放大。在互联网历史的相对早期——当时只有 14 岁——发现了第一个 DoS 放大攻击。大概在 1997 年，尽管很难确定确切的日期。

第一次真正的 DoS 攻击发生在一年前，1996 年。Smurf 的工作原理是制作带有欺骗性源地址的 ICMP 数据包，并将这些数据包发送到网络的广播地址。收到请求的主机会将数据包发送到目标，如果多个主机响应，您就可以免费获得更大的 DoS 攻击。快进到 1999 年，第一个僵尸网络实现了分布式拒绝服务攻击。从那以后，DDoS 流量的规模和缓解能力不断升级。

DNS 和 NTP 很快成为放大的流行选择，NTP 请求管理 556 的放大系数，这意味着攻击者发送的每一个字节，放大中介将向受害者发送 556 个字节。您可能注意到，到目前为止，没有一个易受攻击的服务使用 TCP。TCP 的三次握手通常可以防止放大攻击所需的那种误导。简单来说，你不能用 TCP 有效的欺骗你的源地址。

城里有两种新游戏，第一种是[对“中间盒”](https://arstechnica.com/information-technology/2022/03/unending-data-floods-and-complete-resource-exhaustion-ddoses-get-meaner/)、防火墙、入侵防御系统和内容过滤器等设备的巧妙利用。这些设备监视流量，过滤内容或潜在的攻击。这里的关键是，许多这样的设备实际上并不跟踪 TCP 握手，这将是令人望而却步的内存和 CPU 密集型。相反，大多数这样的设备只是检查尽可能多的数据包。这就有了打败 TCP 内置反欺骗的意想不到的效果。

攻击者可以发送一个欺骗的 TCP 数据包，不需要握手，易受攻击的中间体将会忽略它是欺骗的事实。虽然这本身很有趣，但真正值得注意的是当数据包看起来是对易受攻击或被阻止的资源的请求时会发生什么。设备尝试中断该流，并向请求者发回一条错误消息。由于请求者可能会被欺骗，因此可以将这些器件用作 DDoS 放大器。由于这些服务中的一些用实际上是整个网页来传达错误的单个包来响应，放大因子实际上是超出图表的。这项研究发表于 2021 年 8 月，今年 2 月下旬，[Akamai 的研究人员已经看到 DDoS 攻击](https://www.akamai.com/blog/security/tcp-middlebox-reflection)实际上在野外使用这种技术。

第二种新技术更加奇特。某些 Mitel PBXs 具有压力测试功能，本质上是类固醇的速度测试。它旨在只用于内部网络，而不是外部目标，但直到最近的固件更新没有强制执行。对于近 3000 个这样的设备，攻击者可以发送一个数据包，并触发针对任意主机的测试。这种攻击最近也在野外出现过，不过似乎是在试运行中。压力测试在最坏的情况下可以持续 14 个小时，如果以包为单位测量超过 40 亿，则导致最大放大系数。最大的问题是，像这样的电话系统一般不会被触及，除非有问题，而且很有可能现场没有人有登录凭证。也就是说，预计这些在未来很长一段时间内都是脆弱的。

## 肮脏的管道

这个 [Linux 漏洞是在野外](https://dirtypipe.cm4all.com/)发现的——不是一个漏洞，而只是一个普通的老 bug。CM4all 的[马克斯·凯勒曼]有一个客户看到了损坏的日志归档。单个损坏的文件并非闻所未闻，但这是相同的每日日志归档，以相同的方式重复损坏。这种可再现性往往会让开发人员兴奋不已，因为这意味着可以追踪并修复特定的 bug。所以，他开始在他的代码中寻找一个 bug。在排除了自己的代码是罪魁祸首之后，他最终得出结论，这是一个内核错误。

> 当你排除了不可能，剩下的，不管多么不可思议，一定是事实。
> 
> —夏洛克·福尔摩斯

这个 bug 原来是 CVE-2022-0847，由两个简单的程序演示:

```
#include <unistd.h>
int main(int argc, char **argv) {
  for (;;) write(1, "AAAAA", 5);
}
// ./writer >foo 
```

和

```
#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
int main(int argc, char **argv) {
  for (;;) {
    splice(0, 0, 1, 0, 2, 0);
    write(1, "BBBBB", 5);
  }
}
// ./splicer <foo |cat >/dev/null 
```

我能够在我的一台机器上复制这个 bug，首先创建一个文件`touch foo`。接下来，启动拼接程序运行:`./splicer /dev/null`。然后最后运行 writer 程序:`./writer >foo`让它运行几秒钟，然后终止这两个进程。如果没有漏洞，那么`foo`将只包含一长串“AAAAA”。在具有易受攻击内核的机器上，grep 揭示了大量混合的“BBBBB”。

这里的关键是`[splice()](https://man7.org/linux/man-pages/man2/splice.2.html)`背后的逻辑。这个系统调用对于快速移动数据非常有用，因为它要求内核在文件描述符之间进行数据复制，而不需要将任何位移动到用户空间。问题是，您可以从错误的一侧调用管道上的接头，这是一种单向通信工具。在上面的示例代码中，重定向操作符`<`用于将数据从文件读入流程的标准输入。在引擎盖下，有一根管子，你可以把 T2 放进管子里。系统调用将请求的数据移动到缓存中，然后检查是否允许拼接完成。在 Linux 5.8 中，一个关于如何处理这个缓存的老问题最终变成了一个严重的错误。突然，一些`splice()`请求在不应该完成的时候完成了。

该漏洞允许任何用户向他们拥有读取权限的任何文件写入数据。那很糟糕。有几个注意事项——主要是用户必须对要被篡改的路径和文件有读取权限。在我的系统上，这意味着`/root/.ssh/authorized_keys`不能被篡改。其次，这个漏洞不能改变文件的大小——它只会覆盖数据，而这种覆盖不能包括文件的第一个字符。乍一看，这大大降低了严重性，但是稍微复杂一点的参与者可以使用另一种方法:修改 setuid 二进制文件。如果可以改变二进制，就可以引入自己的漏洞。总之？此漏洞会将任何具有交互式外壳的人提升为超级用户。

编辑:感谢 Gravis 指出此处缺失的信息。DirtyPipe 是作为内核 5.8 中重构的一部分引入的，并在 5.16.11 和 5.15.25 中得到修复。LTS 内核 5.10.102 也收到了后端口修复。

## 更多失误$新闻

这个故事不断给出，还有一堆发展要报道。首先，Nvidia 泄露的部分内容是一个旧的签名密钥。这已被证明是攻击者的有力工具，而不是无用的黑客证据。为什么？Windows 支持使用过期签名签名的驱动程序。并且，[泄露的 sig 已经被用于攻击](https://threatpost.com/nvidias-stolen-code-signing-certs-sign-malware/178784/)。

> LAPSUS$勒索集团已经成功攻破了英伟达和三星。
> 
> -3 月 1 日:他们要求 NVIDIA 开源其驱动程序，否则他们将
> -3 月 4 日:LAPSUS$发布三星专有源代码。
> 
> 更多详情请直接从 pic.twitter.com/U3VD7R2KRl 的 LAPSUS$ [获取](https://t.co/U3VD7R2KRl)
> 
> —VX-underground(@ vxunderground)[2022 年 3 月 4 日](https://twitter.com/vxunderground/status/1499882337957515274?ref_src=twsrc%5Etfw)