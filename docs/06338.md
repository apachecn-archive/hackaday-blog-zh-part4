# COBOL 不是问题:一个被误解的危机

> 原文:[https://hack aday . com/2020/04/20/cobol-not-the-issue-a-deflected-crisis/](https://hackaday.com/2020/04/20/cobol-isnt-the-issue-a-misinterpreted-crisis/)

历史注定会重演吗？或者说，考虑到最近的新闻事件，真的有任何疑问不是吗？我说的当然是新泽西要求 COBOL 程序员修复他们古老的失业系统，这个系统在新冠肺炎封锁导致的申请高峰下崩溃了。不久之后，其他国家也加入进来，令人痛苦的是，我们显然没有从 2000 年问题中学到任何东西:我们仍然依赖同样的老古董来运行我们的基础设施，我们仍然认为人们愿意自愿编写 COBOL。

或许他们有？在接到求助电话后，事情变得异常紧张。IBM 宣布提供免费的 COBOL 培训，并推出了一个[论坛](https://community.openmainframeproject.org/c/calling-all-cobol-programmers/15)，程序员可以在这里展示他们的技能和可用性。开放主机项目的 [COBOL 编程课程](https://github.com/openmainframeproject/cobol-programming-course)突然登上了 GitHub 项目趋势的榜首，谷歌趋势也显示了 COBOL 的一个巨大的高峰。COBOL 似乎正在成为 2020 年最热门的语言之一，我们看到一些 MicroCOBOL 在 Teensy 上运行只是时间问题。

然而，令人遗憾的是，正在讨论的失业系统只是依靠几十年旧软件的一小部分系统，这些软件是用很久以前就过时的语言编写的，这使得在当今时代很难找到程序员。这是为什么呢？

最终，COBOL“只是另一种语言”，不管它有多古老，没有什么能阻止任何人学习它或用它开发。仅仅因为它是一种古老的语言，并不意味着 COBOL 完全过时和不相关。计算机语言不会“死亡”，它们只是睡着了。

或者就 COBOL 而言，使用这种语言更有意义的领域是有限的和高度特定的。COBOL 的自然领域是可靠的大容量数据处理，它是这方面的完美语言。COBOL 作为一种通用语言已经过时了。

因此，也许寻找 COBOL 程序员的问题并不在于这种语言，而在于它的使用对使用它的系统意味着什么，以及人们可以期待的工作环境。事实是，这些系统是他们那个时代的产物，在那个时代，我们今天所知道的开发过程和方法根本不存在，嵌入在软件仅仅被视为工具(如果不是令人讨厌的话)的行业中。但是 COBOL 本身在这里是不相关的，我们会在任何其他语言的相同情况下。更糟糕的是，如果我们不开始最终解决手头的实际问题，或者至少从中吸取教训，并继续将一切归咎于一种古老的语言，历史*将会*重演，其他语言也将面临同样的情况。

但是我在谈论什么问题呢？好吧，那就从最开始说起，对 COBOL 的不爱。

## COBOL 颂歌

虽然几乎每个人都以这样或那样的方式听说过 COBOL，并声称你认识的人曾经使用过它，这为你赢得了一些严肃的街头信誉，但这种语言在 Hackaday 上并没有得到太多的关注。如果不是为了纪念那些参与其早期开发的人的生活和工作，以及为其铺平道路的 T2，我们几乎看不到任何关于它的东西。但这也不应该让人感到意外，毕竟这是 T4 通用的商业语言。还有比这个名字更让黑客反感的吗？与 BASIC 不同，考虑到它的主要应用领域，怀旧也不会有太大帮助。

[![](../Images/2c773a74c99f29e5326d40a62b27e7d1.png)](https://hackaday.com/wp-content/uploads/2020/04/gracehopper_thumbnail.png) 因此，COBOL 作为一种要求你带着领带和扫把棍上班的无聊语言，有着酸酸的一面味道。然而，COBOL 是计算机历史上一个明确而重要的部分，正如我们从最近的新闻中看到的，在最初的会议开始 61 年后，它仍然发挥着重要的作用。根据我们的观察，它甚至可能是这个领域的主导语言。

根据经验，系统故障对社会造成的灾难越大，就越有可能在其中发现 COBOL，银行通常是主要的例子，此外还有保险、卫生部门、民用基础设施，当然还有政府管理部门，如前面提到的失业系统。再看[一些数字](http://fingfx.thomsonreuters.com/gfx/rngs/USA-BANKS-COBOL/010040KH18J/index.html)，2017 年美国 43%的所有银行系统、80%的销售点、95%的 ATM 交易使用并依赖 COBOL 代码，再看其他国家也不会有太大区别。

总而言之，用 COBOL 编程可以让你在难以置信的性感环境中工作，这种环境可以轻松地跟上游戏或 web 开发的兴奋和酷劲——而不是。

## 代际冲突

是的，是的，除了那些被宠坏的年轻人，他们甚至不知道如何用螺丝刀改变寄存器值，不是每个人都关心这个或想做噱头式的 web 或游戏开发——但这就是重点。每当提到 COBOL 短缺时，主要问题似乎是懂这种语言的老一代人已经离开了活跃的劳动力大军。与此同时，自 2000 年以来，我们已经前进了整整一代人，而这仍然是同样的问题。然而，那些在上一次 COBOL 大危机期间出生的人现在正在慢慢进入就业市场，成为新的开发人员，人数比以往任何时候都多，他们的思维方式、技能和兴趣与这种语言和使用它的系统相去甚远。

[![](../Images/89ad259f2d45ef011032e998318544e5.png)](https://hackaday.com/wp-content/uploads/2020/04/thumbnail.png) 为什么会这样？软件开发和其中的机会与 90 年代完全不同，更不用说 60 年代了。请记住，我们在谈论的这一代人，计算机不是一种神奇的神奇设备，而是一种商品。曾经是革命性的东西，充其量不过是最低限度的。

但是吸引力、兴趣和魅力的代际差异真的只是冰山一角上的海鸥。不，小学必修的 COBOL 课程不是解决办法。此外，这并不是说你不能从 Node.js 或者 T2 运行 COBOL 来迎合那些年轻的 web 开发者。

另一方面，不同的人有不同的选择，所以商业领域或其吸引力可能不一定是一个问题。我的意思是，我有什么资格质疑人们的偏好，为大型机开发听起来绝对令人兴奋。但是事情是这样的:这些对 COBOL 程序员的紧急召唤只在有危机需要避免的时候才会出现，所以你很可能最终只是一个代码看门人，一旦工作完成，他的用处就结束了。换句话说:缺乏工作保障是塞翁失马，焉知非福，因为无论如何，你的工作很可能会令人沮丧、枯燥乏味。

剩下的人要么不关心这些，要么公开声称他们将如何做两年多的全职工作，每小时 400 美元，还有一个免费的香蕉。在某种程度上，他们说得有道理，但第一组肯定会赢得竞标。为什么？因为这种价值观、兴趣和期望的代际不匹配是双向的，而且我们谈论的行业在很大程度上并不适合软件开发。

## 揭示真相的数字

让我们再来看一看[之前](http://fingfx.thomsonreuters.com/gfx/rngs/USA-BANKS-COBOL/010040KH18J/index.html)的那些数字，并关注我还没有提到的那个数字:*现存的 2200 亿行代码*。随便找一篇关于 COBOL 的文章，你肯定会发现同样的数字(200 亿，取决于年份)，大概是为了展示这种语言和运行它的系统是多么无所不在。

是吗？还是说它揭示了 COBOL 实际应用的行业的时代精神，以及当今软件世界和那些迫切需要它帮助的人之间的分离？这意味着这毕竟是一个过时的问题，但它仍然不是语言，而是软件被感知的方式。

[![](../Images/7e3170dd91be9a74150ed715fd49d494.png)](https://hackaday.com/wp-content/uploads/2020/04/cobol2.jpg) 我的意思是，上一次*行代码*与软件开发人员，甚至他们的主管有任何关联是什么时候，尤其是越多越好？如果说有什么不同的话，那就是如今人们引以为豪的是，他们只用了几行字就解决了一个常见的问题。想想在火焰战争中浪费的数百万小时，只要简单地展示 Linux 的[~ 5000 万行](https://www.openhub.net/p/linux/analyses/latest/languages_summary)如何使它明显优于 FreeBSD 的微不足道的[~ 2500 万行](https://www.openhub.net/p/freebsd/analyses/latest/languages_summary)，以及为什么 OpenBSD [仍然击败它们所有的](https://www.openhub.net/p/openbsd/analyses/latest/languages_summary)，就可以节省这些时间。(根据这一标准， [Emacs](https://www.openhub.net/p/emacs/analyses/latest/languages_summary) 将击败 [Vim](https://www.openhub.net/p/vim/analyses/latest/languages_summary) ，从而证明了我的观点，即代码行显然没有意义。)

但好吧，也许这个数字只是一个有趣的事实，我严重过度解读了它。不过，也许我不是，它确实提供了一些关于在 COBOL 工作环境中会发生什么的意想不到的见解，在 COBOL 工作环境中，软件开发被视为纯粹的体力劳动，就像在工厂中冲压金属板一样。不要忘记在简历中加入你的每分钟字数。

不管怎样，这还不是全部。那我们来谈谈代码吧。

## 机器中的幽灵

你多久看一次别人的代码，然后确信自己可以做得更好？你有多长时间不得不处理遗留代码并诅咒它的作者？如果你幸运的话，你可以重构它，继续你的生活。如果没有，你可能会在中途意识到任何事情的发生都是有原因的，不管它看起来有多奇怪，你最终会找到一种不太优雅的方法来解决它，引入新的特殊代码，下一个人可能会觉得有问题。

现在想象这是常态。不仅如此，想象一下在代码库中堆积了几十年又几十年的变通方法是如何成为系统本身的核心的。毫无疑问，每一个补丁都有其存在的理由和有效性，无论是谁写的，都知道他们在做什么。也许下一个从事这项工作的人，加上他们自己的变通办法，已经存在了足够长的时间，足以记住必须小心处理的某些特定怪癖的一切。但那是十次迭代，30 年前的事了。从那以后，最初的业务被收购了两次，重组了三次，每一次都与另一个以完全相同的方式发展的系统整合在一起。

[![](../Images/a43c924caeb4def46a87a9c3073158dc.png)](https://hackaday.com/wp-content/uploads/2020/04/133584518_906fb99bc2_b.jpg)

Image CC BY-ND 2.0 [Jason Tester Guerrilla Futures](https://search.creativecommons.org/photos/0a3bb511-e28d-482d-9e93-99d0c35a45f5)

请记住，我们谈论的是对我们的基础设施至关重要的系统。他们不间断的运行是至关重要的，几十年前，你不能在去办公室的路上尝试一些解决方案，也不能在午餐时间运行一些自动化测试。无论做什么工作都必须足够好，我们非常清楚，没有什么比有效的临时解决方案更长久的了。考虑到 2000 年问题首先成为一个问题，人们显然没有想到这些系统在未来几十年仍然是相关的。

好吧，他们做到了，而且不归路早就过去了。再加上对软件的心态和程序员的可替代性，事情只会越来越糟。如果 2000 年是一个问题，因为最初开发该系统的人已经离开了工作岗位，那么一代人以后，当那些不得不煞费苦心地找出所有怪癖来添加新的变通办法的人也退休了，我们还能期待什么呢？

不过还是那句话，这与 COBOL 无关，向人扔 COBOL 课程不会是银弹。如果有什么不同的话，那就是需要一种抗挫折的心态、毅力和很高的痛苦阈值来挖掘代码——这是你无法教会的，并且重复同样的老话“我们需要 COBOL 程序员！”圣歌几乎不会增加拥有这些能力的人的数量或可用性。当然，修复系统需要 COBOL 技能，但是单靠 COBOL 技能不会让你走得太远。

## 走向更光明的明天

那么什么是解决方案呢？我希望这足够明显，这个问题在整体上太复杂了，没有一个*单一的*解决方案，我提到的每一个方面，我相信甚至没有涵盖整个画面的一半，都需要单独考虑。

有一点是肯定的，事后回想起来，一切都应该以不同的方式在 60 年代或 90 年代处理不会削减它，也不会从头开始写一切。一点一点地做到这一点可能是一个好的开始，但是首先使代码库成为问题的复杂性不会以这种方式得到解决。如果有的话，它冒着使事情更加复杂的风险，因为它需要充分分析和理解每一个小细节和怪癖，没有错误或猜测的余地。这将需要年复一年的计划，当大多数系统现在看起来“运行良好”时，谁愿意投入时间和金钱呢？

至于其他问题，嗯，你不能改变人。但是你可以试着去理解它们——这是双向的。是的，当代人使得软件工程可能是有史以来最被宠坏的职业之一，但是仅仅因为你过得更糟而没有抱怨并不意味着其他人都愿意自己经历这些——就像技术基础和它们在实践中似乎过时的历史仍然是有价值的，值得知道。

[![](../Images/74de80567edde2945ed85cfb41ba2473.png)](https://hackaday.com/wp-content/uploads/2020/04/cobol3.jpg) 我们确实生活在一个与运行 COBOL 的系统不同的时代。软件的无处不在不仅提供了全新的令人兴奋的工作领域，而且有希望表明，对于那些与该领域没有直接关系的人来说，它不仅仅是一个成本因素。如果不是，那么让我们至少从中吸取教训。我们很难责怪当时不了解情况的开发人员或他们的主管，但如果我们不开始最终从中吸取教训，下一次肯定会是我们。这适用于研发部门内外的领域。

与 60 年甚至 20 年前不同的是，今天我们有太多的工具供我们使用，这些工具允许我们跟踪软件中的变更、进展、问题和需求，主要是以问题跟踪和版本控制的形式。但是，如果只是为了完成而不认真地进行改编，这些都没有用，而且`"fixed stuff."`提交消息— [*甚至不要让我开始编写代码文档！*](https://hackaday.com/2019/03/05/good-code-documents-itself-and-other-hilarious-jokes-you-shouldnt-tell-yourself/) 我们看待软件开发的方式可能与 60 年前有所不同，但我们仍然有很长的路要走，以调整我们的心态，直到我们不再重复犯同样的错误。

好吧，至少下一次危机会涉及到更多的共同语言，到那时，每个修复今年失业系统的人都有望平静地退休。我相信，头条新闻不会要求 Pascal 或 C 开发人员，所以也许我们终于可以停止假装这是一个 COBOL 问题，当它实际上是一个“可怕的工作期望”问题。

最后，我会很高兴听到那些当时参与预防千年虫的人的故事！