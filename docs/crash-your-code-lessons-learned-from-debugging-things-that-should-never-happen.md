# 崩溃你的代码——从调试不应该发生的事情中学到的经验

> 原文：<https://hackaday.com/2019/01/22/crash-your-code-lessons-learned-from-debugging-things-that-should-never-happen/>

老实说，没有人喜欢看到他们的程序崩溃。这清楚地表明我们的代码有问题，这是我们不愿意看到的事实。我们尽最大努力避免这种情况，我们已经看到了[编译器警告](https://hackaday.com/2018/11/06/warnings-are-your-friend-a-code-quality-primer/)和[其他静态代码分析工具](https://hackaday.com/2018/12/12/warnings-on-steroids-static-code-analysis-tools/)如何帮助我们检测和防止代码中可能的缺陷，否则这些缺陷可能会导致代码的消亡。但是，如果我告诉你，崩溃你的程序实际上是一个伟大的方式来提高其整体质量呢？现在，这显然听起来有点违反直觉，毕竟我们在谈论防止我们的代码行为不当，那么我们为什么要故意破坏它呢？

徘徊在 1 和 0 的环境中很容易让人忘记现实通常不是黑白分明的。是的，程序崩溃是不好的——它伤害了自我，让我们看起来很糟糕，最重要的是，它很烦人。但这真的是最坏的情况吗？比方说，如果一些糟糕的指针处理没有导致即时分段错误，而是愉快地将一些垃圾数据引入系统，从而为几乎任何可以想象的结果打开大门，从小故障到严重的安全漏洞。这真的是更好的选择吗？它不一定是指针，也不一定是 C 语言的任何缺点，实际上在任何语言中，我们都可能以无效数据和不可预见的场景而告终。

不管我们听到多少次，软件的每一部分都太复杂，以至于无法完全理解它，或者所有可能出错的东西将如何出错。我们充分意识到所有的智慧和陈词滥调，每当我们在代码中添加一个`/* this should never happen */`注释时，我们就完全忽略它们或者回避它们。

因此，今天，我们将研究我们处理这种意外情况的选项，我们如何在未来利用故意崩溃来改进我们的代码，以及为什么一般的错误消息大多是无用的。

## 当事情出错时

让我们坚持一个场景，在这个场景中，我们最终会得到意想不到的垃圾数据。我们如何陷入这种情况可能有许多原因:糟糕的指针处理、未初始化的变量、在定义的边界之外访问内存，或者过时数据的糟糕清理例程——仅举几例。这种情况如何结束，当然取决于我们执行的检查，但更重要的是，我们到底在处理什么数据。

在某些情况下，后果会相当明显和即时，我们可以马上调查它，但在最糟糕的情况下，垃圾有足够的意义，最初不会被发现。也许我们正在使用有效但过时的数据，或者数据碰巧全是零，在正确的位置进行`NULL`检查可以避免灾难。我们甚至可能一起逃脱。直到代码第一次在一个完全不同的环境中运行。

有了示例，一切都变得简单了，所以让我们假设我们收集了一些由时间戳和 0 到 100 之间的值组成的通用数据。每当数据的时间戳比前一个数据的时间戳新时，我们将对该值做一些事情。

```

struct data {
    // data timestamp in seconds since epoch
    time_t timestamp;
    // new data value in range [0, 100]
    uint8_t value;
};  

void do_something(struct data *data) {
    // make sure data isn't NULL
    if (data != NULL) {
        // make sure data is newer than the previous
        if (data->timestamp > last_timestamp) {
            // make sure value is in valid range
            if (data->value <= 100) {
                // do something with the value
                ...
            } else {
                // this should never happen [TM]
            }
            // update timestamp
            last_timestamp = data->timestamp;
        }
    }
}

```

这似乎是一个合理的实现:没有意外的`NULL`解引用，并且逻辑与描述相匹配。这应该涵盖了所有的基础——很可能是这样，直到我们最终得到一个指向几千年后的假时间戳的指针，导致在那之前所有进一步的值处理都被跳过。

通常，像这样的问题可以通过调整验证检查来解决。在我们的例子中，我们可以包括当前时间，并确保时间差在某个时间段内，我们应该没问题。直到我们最终发现时间戳是正确的，但值却不是。也许我们看到了很多异常值，所以我们添加额外的逻辑来过滤掉它们，或者用一些平均算法来平滑它们。

因此，检查数据是否较新以及是否在定义的范围内这一看似琐碎的任务在整体复杂性上爆炸了，这可能会导致更多我们没有想到的、需要在以后处理的死角情况。更不用说我们忽略了一个简单的事实，那就是我们正在处理的数据本来就不应该在那里。我们本质上是治标不治本。

## 在该崩溃的地方崩溃

问题是，当我们发现我们的数据不如预期时，已经太晚了。通过解决这些症状，我们不仅引入了不必要的复杂性(我们很可能不得不将它拖到数据被传递到的每个其他地方)，而且还掩盖了隐藏在下面的真正问题。那个隐藏的问题不会因为忽略它而消失，迟早它会引起真正的后果，迫使我们永远调试它。只不过，到那个时候，我们可能已经很好地模糊了它的路径，以至于需要付出更多的努力才能找到问题的根源。

最糟糕的情况是，我们永远也不会到达那里，相反，我们不断地实现一个又一个解决方案，原地打转，等待下一个 bug 的出现。我们小心翼翼地回避这个问题，只是为了让项目继续运行，而忽略了这作为一个长期解决方案是多么徒劳。我们还不如放弃，现在就放弃——我说，你应该这么做。

当然，中断我们的项目也不是长久之计，但这也不是长久之计。它的意思是作为一个指标，我们结束了一个我们没有预料到的情况，因此我们的代码没有准备好正确处理它。是什么把我们引向那里，我们是在处理一个实际的 bug 还是在我们的实现中简单的有缺陷的逻辑，这是一个不同的故事，需要我们去发现。

显然，崩溃本身不会解决问题，但它会给我们一个具体的起点，看看下面隐藏着什么。如果我们在几个变通办法之后从某个地方发生的崩溃中恢复过来，我们可能会在同一个地方结束，但我们在早期故意的崩溃让我们跳过这一点，并给我们一个良好的开端。换句话说，花几分钟在一个小麻烦上，比如实现一个适当的检查，可以节省我们几个小时令人沮丧的调试时间。

所以让我们崩溃我们的代码！一种常见的方法是使用`assert()`，在这里我们给出一个预期的条件，如果该条件为假，`assert()`调用将导致程序中止。让我们走极端，用断言代替例子中的所有条件。

```

void do_something(struct data *data) {
    // make sure data is not NULL
    assert(data != NULL);

    // make sure timestamp is valid and update it
	assert(validate_timestamp(data->timestamp));
	last_timestamp = timestamp;

    // make sure the value is in valid range
	assert(data->value <= 100);

	// do something with the value as before
    ...
}

```

现在，在出现无效数据的第一个迹象时，相应的断言将失败，并且程序执行被中止:

```

$ ./foo
foo: foo.c:64: do_something: Assertion `data->value <= 100' failed.
Aborted (core dumped)
$

```

太好了，我们找到了要找的坠机地点。断言只有两个问题。

### 断言是可选的

从设计上来说，断言是开发过程中的调试工具，尽管 libc 文档建议不要这样做，但在发布版本中禁用断言是常见的做法。但是，如果我们在开发过程中没有发现问题，而某一天它在野外出现了呢？很有可能，这就是将要发生的事情。如果没有断言代码，既不会执行防止问题的检查，也不会获得任何相关信息。

好吧，我们在这里讨论的是故意让代码崩溃，所以我们可以养成一个习惯，总是让断言保持启用，不管是调试还是发布版本。但是还有一个问题。

### 断言消息是无用的

如果我们看一下失败断言的输出，我们就会知道哪个`assert()`调用失败了:确保值在有效范围内的那个调用。所以我们也知道我们正在处理一个无效的值。我们不知道的是没有通过断言的实际值。

当然，如果我们碰巧得到了一个核心转储，并且可执行文件包含调试信息，我们可以使用`gdb`来找到更多相关信息。但不幸的是，在我们自己的开发环境之外，我们并不经常有这种奢侈，我们不得不使用错误日志和其他调试输出来代替。在这种情况下，我们剩下的产出价值很小。

不要误解我的意思，确切地知道哪里出了问题肯定比没有任何提示更有帮助，断言在这里为小的努力提供了很大的价值。这就是问题所在:如果另一种选择是完全没有输出，那么是的，知道我们的问题发生在哪一行似乎是一个我们可以满足的大胜利。考虑到错误处理通常在程序员中很受欢迎，很容易理解为什么我们会对此感到满意——但是说实话，我们不应该如此。另外，它助长了我们自己编写错误消息的坏习惯。

## 崩溃更好

如果您曾经发现自己处于这样一种情况，您有无数关于完全相同的问题的报告，并且您足够幸运地拥有每个单独事件的错误日志，您将会了解到知道某个条件失败了，但却不知道到底是什么导致了失败，这是多么令人沮丧的无助。当你意识到并了解到没有任何细节的“预期情况不真实，句号”形式的错误信息是多么的无用，而且几乎是适得其反。

考虑以下两条错误消息:

1.  `Assertion `data->value <= 100' failed`
2.  `data->value is 255, expected <= 100`

在第一种情况下，我们只知道值大于 100。由于我们处理的是一个 8 位整数，它留给我们 155 个可能的选项，我们可能必须在脑海中浏览每一个选项，以了解可能出错的地方，从一个不确定的假设跳到下一个，试图找出可能导致这一切的值。

然而，在第二种情况下，我们可以跳过所有这些。我们已经知道是什么值导致了错误，将我们的调试思维从一般的“为什么我们得到一个无效的值？”变成具体的“我们怎么会有 255 个在这里？”。这给了我们另一个发现真正问题的开端。

因此，与其坚持断言和它们有限的信息，不如让我们实现我们自己的崩溃函数，让它输出我们想要它输出的任何东西。使用可变参数列表的简单实现如下所示:

```

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

void crash(char *format, ...) {
    va_list args;

    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);

    exit(EXIT_FAILURE);
}

```

这样，我们可以像对待`printf()`一样格式化我们的错误消息，并且我们可以添加我们想要的所有信息:

```

if (data->value <= 100) {
    // validation passed, handle the data
    ...
} else {
    crash("data->value is %d, expected <= 100\n", data->value);
}

```

请注意，与断言的输出不同，我们在这里没有获得确切位置的信息，但这只是为了简单起见。我在 GitHub 上放了一个更复杂的`crash()`函数来输出更多的细节，包括打印函数回溯，以防你好奇。

关于 C 语言，谷歌已经开发了[一堆杀毒工具](https://github.com/google/sanitizers)，现在集成在 [`gcc`](https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html) 和 [`clang`](https://clang.llvm.org/docs/AddressSanitizer.html) 中，值得一试。

## 没有所谓的“信息太多”

请记住，我们关注的是我们没有预料到的问题。一些“本不该发生”的事情神奇地发生了。承认它确实可能发生，并因此对其进行适当的检查，是重要的第一步。但是我们如何知道在我们的错误消息中放入什么呢？我们还不知道我们实际上需要知道什么，或者什么可能会出错——如果我们知道，我们不会认为这是永远不会发生的情况，但我们会试图从一开始就防止它。

简单的答案是:全部。

当然，显然不是所有的细节，但是每一个细节，只要与情况有一点点相关，都值得包含在错误信息中。一旦我们添加了验证检查，我们就有了所有可用的信息，为什么不使用它呢？

以我们的数据收集示例中的时间戳为例:仅仅因为它被成功验证并不意味着我们应该忘记它。它仍然可以为失败的值验证提供有价值的调试信息。谁知道呢，也许它会在每整点钟，或者每天下午 6:12:16 揭示一个问题，或者没有显示任何模式。无论哪种方式，都有可能帮助我们缩小调试路径，并使我们更接近实际问题。

即使事实并非如此，额外的信息被证明是完全不相关的，我们也可以过滤掉或者忽略它。然而，我们不能在崩溃后添加它。因此，不要羞于在错误消息中添加尽可能多的信息。

## 选择你的战斗

当然，并不是所有的意外情况或无效数据场景都必然导致崩溃。当验证随机用户输入时，或者当您请求数据的远程服务器不可达时，或者在处理超出您直接控制的数据的任何情况下，您可能都不想中止整个程序。但是另一方面，这些情况也不是完全出乎意料的，所以有一个默认的后备工作区，或者输出一个没有崩溃的错误，是处理这种情况的有效方法。

然而，养成提供尽可能详细的有意义信息的习惯可以帮助每个人更好地理解问题。举几个例子:

*   `Parsing input failed`vs
    
*   `Error loading data`vs
    
*   `Assertion `data->value <= 100' failed`vs
    

作为程序员，我们从小就被灌输错误处理的重要性，但在早年，我们很少学习如何正确地利用它，我们可能看不到任何实际的好处，甚至根本看不到它的用处。随着时间的推移，错误处理(除了代码文档和测试之外)经常成为我们不得不处理的烦恼，以便让其他人高兴:老师、主管或那个特别迂腐的队友。我们最终基本上是“为他们”而做的，我们很容易忽视我们自己实际上是从中受益最多的人。

不幸的是，没有讲故事可以代替艰难的学习，但希望我仍然可以提供一些思考的食物和对这个主题的新观点。

从这个意义上来说:快乐坠毁！

(横幅图片来自失传已久的 [Crash Bansai](https://web.archive.org/web/20130730071824/http://www.crashbonsai.com:80/index.html) 变态玩具汽车画廊，用于病态的微型园艺。)