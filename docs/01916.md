# 你能信任你的 C 编译器吗？

> 原文:[https://hack aday . com/2019/01/24/can-you-trust-your-c-compiler/](https://hackaday.com/2019/01/24/can-you-trust-your-c-compiler/)

如果你正在编写一个 hello world 程序，你可能不会太关心编译器如何把你的源代码翻译成机器码。然而，如果你的代码运行在人们生活所依赖的东西上，你会想要更挑剔一些，使用类似于 [COMPCERT](http://compcert.inria.fr/) 编译器的东西。这是一个经过正式验证的编译器，意味着有一个数学证明，你用 C 写的东西将被正确地翻译成机器代码。编译器可以为 PowerPC、ARM、RISC-V 和 x86 生成，接受带有一些扩展的 ISO C 99 子集。虽然它生成的代码没有 gcc 运行得快，但您可以肯定生成的代码会完成您要求它做的事情。

当然，这仍然不能保证您的代码能够工作。这只是意味着，如果你写一些像“x = 0；”生成的代码会将 x 设置为零，不会做任何其他事情。您可以应用正式的方法来验证您的源代码，并确保编译器不会引入可能的错误。像“x = 0；”这样的代码额外的事情或不正确的事情很难弄清楚，因为源代码是正确的，并且有必要检查生成的代码以发现编译器的代码生成错误。

所有这些都有一些限制。例如，可变长度数组类型不可用，您不应该使用 longjmp 和 setjmp。对如何编写 switch 语句也有一些限制。还有各种选项允许你在解释器下检查你的代码[。](http://compcert.inria.fr/man/manual004.html#sec51)

你可能认为你的编译器不需要验证，但你可能会感到惊讶。编译器文档引用了从 1995 年到 2011 年的几篇论文，这些论文发现了流行编译器的许多错误编译问题。

COMPCERT 对程序的可观察行为进行操作，例如对 I/O 函数的调用或对易失性内存位置的访问。编译器可以改进程序的可观察行为，例如，解决被零除的错误，但不能改变其他行为。但是，请注意，虽然您可能认为执行时间和内存使用是外部可观察的，但它们在此上下文中不算数。

为了使证明易于管理，Coq proof assistant 对编译器证明进行自动检查，编译器本身使用 15 遍，每一遍都被证明是正确的。到今天为止，仍然有大约 10%的编译器没有被证明是正确的。研究人员使用 Csmith 花费了 6 个 CPU 年的时间来寻找编译器错误，但没有发现任何错误(其他编译器则没有)。

当然，让你的程序[做你想让它做的事情](https://hackaday.com/2019/01/22/crash-your-code-lessons-learned-from-debugging-things-that-should-never-happen/)仍然取决于你。这一切都是为了确保编译器按照你的要求去做。幸运的是，有工具可以帮助[正式验证你的代码](https://hackaday.com/2018/12/12/warnings-on-steroids-static-code-analysis-tools/)。