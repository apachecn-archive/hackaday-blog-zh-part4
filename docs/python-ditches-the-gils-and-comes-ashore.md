# 蟒蛇抛弃了吉尔，来到岸上

> 原文：<https://hackaday.com/2021/11/03/python-ditches-the-gils-and-comes-ashore/>

Python 世界以前已经分裂过几次。从版本 2 到版本 3 的臭名昭著的过渡仍然影响着今天的人们，并且在未来可能会有新的分裂。[Sam Gross]提出了一个[解决方案来丢弃全局~~中断~~解释器锁(GIL)](https://mail.python.org/archives/list/python-dev@python.org/thread/ABR2L6BENNA6UPSPKV474HCS4LWT26GY/) ，这将对许多利用 CPython 内部机制的项目产生巨大的影响，比如 Pandas 和 NumPy。

Python 被解读的事实是一把双刃剑。这意味着可以有不同的运行时，如 Pyston、Cinder、MicroPython、PyPy 等，它们可能支持整个语言、特定版本或子集。但是如果你用的是 Python，你很可能运行的是 CPython。它有一个影响线程代码的全局解释器锁。简而言之，解释器中一次只能运行一个线程。有一些方法可以解决这个问题，比如将对性能至关重要的部分转移到 C 中，或者使用多个解释器。然而，大多数现有的解决方案都有相当大的缺点。

## 为什么会有 GIL，你是如何移除它的？

当你能保证一次只有一个线程运行时，程序状态更容易推理。如果没有 GIL，引用计数、内存分配、方法解析顺序缓存和垃圾收集都不是线程安全的。[Sam]在他的概述文档中讨论了这一演变。

要摆脱 GIL，首先要对引用计数进行重大修改。为了知道垃圾收集器是否可以释放内存中的对象，它会计算对该对象的所有引用。目前，引用计数是非原子的，将所有引用计数操作改为原子的会对性能产生巨大影响。

该提案使用了一种称为[的技术，偏向引用计数](https://dl.acm.org/doi/10.1145/3243176.3243195)用于本地和共享引用。本地引用可以利用非原子操作，并且拥有线程结合本地引用和共享引用来跟踪所有权。这种方法非常适合单线程或很少被几个线程使用的对象。有几个对象，比如 interned strings、True、False 和 None，在程序的生命周期内存在，并且可以被标记为不朽，从而将它们的引用计数开销减少到零。通过利用引用计数字段中的最低有效位，对象被标记为不朽。经常被访问但不能保证是不朽的对象会延迟引用计数。这意味着唯一需要的引用计数是在引用存储在堆上的时候。这种变化的一个副作用是对象不能被立即回收，因为需要扫描堆栈来寻找任何剩余的引用。

[Sam]用[mimalloc](https://github.com/microsoft/mimalloc)取代了标准的`pymalloc`内存分配器，这是对`malloc`的替代，提供了线程安全和性能。这种交换的好处是，这个分配器允许运行时在没有显式列表的情况下找到 GC 跟踪的对象。这是一个显著的性能提升，但这意味着你不能仅仅换出另一个`malloc-`兼容的分配器，并期望同样的线程安全性用于垃圾收集和回收。

说到收藏和字典，它们在这次手术中被稍微调整了一下。在今天的 CPython 中，他们的设计是“线程安全的”，但是它依赖于 GIL。例如，它们有一个写锁，但没有读锁，如果没有 GIL 来实现原子读，并发写可能会在读的过程中发生。

也许最令人惊讶的变化是将解释器从基于堆栈的虚拟机移动到基于寄存器的虚拟机，大致基于 V8。这是引用计数更改有效的必要条件。就功能而言，它的操作是相同的，但是它会导致大量的代码变动。

## 这对社区意味着什么？

对于 Python 扩展库的作者来说，他们需要做一些必要的工作。例如，所有的 C 库都需要重新编译，因为 ABI 已经改变了。然而，仍然需要 GIL API(比如`PyEvalReleaseThread`)来将状态标记为附加或分离，这会影响垃圾收集行为。

初始性能基准测试显示，性能与 3.10 版相当，在单线程工作负载中运行速度比 3.9 版快 10%，因为它融合了 3.10 和 3.11 版中的一些优化和修复。这些是单线程性能指标评测的平均值。对于多线程工作负载，GIL 的缺失让它大放异彩，通过运行 20 个线程，以 18 倍的速度超过了默认的解释器。不算太寒酸。

至于并入主线，核心维护者之间的争论仍在继续。有些人[呼吁将不相关的性能优化合并进来，将 GIL 手术抛在脑后](https://lwn.net/ml/python-dev/CAP7+vJJ1hzXiyDwVs6-eXed+DtodHJ==Ck680DxAyoiBSXZDQQ@mail.gmail.com/)。有人担心，增加引用计数带来的开销会降低许多现有 Python 程序的速度，其中大多数程序还不是多线程的。

然而，许多著名的参与者和公司将 Python 用于机器学习和 ETL 工作负载，并将从这一变化中受益匪浅。这个提议可能是一些更著名的玩家提供一个具有这些性能提升的 CPython 分支的机会。也许它会获得足够多的追随者，成为 CPython 的有力竞争者？只有时间能证明一切。

## 接下来会发生什么？

GitHub 上发布了[代码，还有一个用于社区讨论的](https://github.com/colesbury/nogil)[地方](https://github.com/colesbury/nogil/discussions)。在维护人员确信这一重大变化不会破坏事物之前，需要进行大量的测试和验证。扩展需要重新编译，现有的多线程代码需要验证，检查被掩盖的并发错误。这可能需要几年时间。

但是 Python 不是静态语言。 [Python 最近得到了 switch 语句，](https://hackaday.com/2021/04/02/python-will-soon-support-switch-statements/)看到 Python 继续发展和变化令人兴奋。希望一切都会变得更好。