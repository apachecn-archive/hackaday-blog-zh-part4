# Linux Fu:有文化的正则表达式

> 原文：<https://hackaday.com/2020/09/11/linux-fu-literate-regular-expressions/>

正则表达式——你提供给像`grep`这样的程序的东西——有点像骑自行车。好像不可能，直到你学会了做，然后就简单了。他们的坏名声的一部分是因为他们使用非常简洁和缩写的语法来警告人们。为了帮助那些每天不使用正则表达式的人，我创造了[这个工具，让你用更接近简单英语的方式来写它们](https://github.com/wd5gnr/regx)。事实上，这些年来我已经写了好几个版本，但是这个针对`grep`的版本是最新的。与以前的一些版本不同，这次我使用 Bash 完成了所有工作。

那些不知道正则表达式的人在看到类似这样的内容时可能会抓狂:

```

[0-9]{5}(-[0-9]{4})?

```

要花多长时间才能弄清楚这是怎么回事？如果你能用一种更有文化的方式来写呢？例如:

```

digit repeat 5 \

start_group \

   - digit repeat 4 \

end_group optional

```

当然，打字没那么快。但是你大概可以推断出它是做什么的:它读取我们的邮政编码。

我发现这些年来我创造的一些最流行的工具是我自己并不需要的。我相信你也有过这样的经历。你知道如何操作电脑，但你为不懂的人创造了一个菜单系统，而他们却喜欢这个系统。这个工具就是这样。你可能不需要它，但是很有可能你认识需要它的人。在这一过程中，代码使用了 Bash 的一些有趣特性，所以即使您不想冗长地使用正则表达式，您也可能会学到一两个技巧。

## 巴别塔

问题之一是没有单一形式的正则表达式。每种工具都有不同的规则和扩展，略有不同。出于这个目的，我的目标是`egrep`，尽管它的大部分也可以在其他系统中工作。一旦有了这个想法，就很容易将它扩展到不同风格的正则表达式。

甚至`grep`也有一些不常见的正则表达式元素，所以我将只使用模式的子集，但它们是您最常使用的。如果您决定要扩展程序，可以很容易地添加更多奇异的甚至包含多个正则表达式模式的宏。

## 工具箱

在我们寻求有文化的正则表达式的过程中，有几件事很重要。这个想法是有一个小程序，将我们的文字转换成正则表达式。我们自然可以将它与 grep 或任何需要正则表达式的工具结合起来:

```

egrep $(regx start space zero_or_more digit repeat 5)

```

`$(...)`构造在其中运行命令，它写出的任何内容都放在命令行上。比如说:

```

for I in $( mount | cut -d ' ' -f 3 )
do
   echo $I
   if [ -f "$I/mountinfo.txt" ]
   then
     cat "$I/mountinfo.txt"
   fi
done

```

这个虚构的示例从 mount 命令中选择每个挂载点，并尝试定位和显示 mountinfo.txt 文件。

所以关键是构建一个`regx`脚本，将我们的冗长语法转换成正则表达式，然后使用`$()`将模式插入命令行。

这些脚本中使用的另一个奇怪的 Bash 工具是正则表达式参数扩展。比如如果`$1="Hackanight"`那么`${1/night/day}`会给你 Hackaday。

## 引用

对于`regx`命令来说，另一个工具并不是真正必需的，但是我想构建一些你可以使用的东西，而不是使用带有`grep`的`$()`符号。问题是你有一个脚本获取参数，然后将它们传递给另一个程序。当你有空间的时候，潜在地，你有一个问题。

如果脚本 A 有`$1="Hack A Day"`,您可以假设命令行使用引号或反斜杠将它们组合成一个字符串。但是将它传递给另一个程序可能会去掉引号，导致另一个程序看到三个不同的参数。在这种情况下，你可以通过`"$1`，那就可以了。但事情并不总是那么简单。

要使`litgrep`工作，您需要了解 Bash shell 扩展，它引用一个值，以便 shell 可以再次读取它:

```

VAR="${1@Q}"

```

在我们之前的例子中，`VAR`现在等于“Hack a Day”(包括单引号)。

## 为什么？

为什么这很重要？因为`litgrep`会挑选命令行参数并发送给`regx`。如果你在争论中有一个空格，它需要整体传递给`regx`。

这里有一个例子:

```

litgrep Hack space a space Day space optional -- *.txt

```

## regx 脚本

这个脚本本身非常简单。有两个函数对字符进行转义，因为正则表达式中有太多的特殊字符。`reesc`函数对反斜杠字符和其他元字符进行转义。在一个类内部(也就是方括号)，没有太多的引用。你一般要把表达式安排正确。例如，要构建一个有破折号的字符类，它需要在前面或后面。我没有试图重新安排你的类，但是你可以在占位符`reescclass`函数中这样做。您还可以将它用于其他一些具有更多转义选项的正则表达式变体。

有三大类模式。大多数人不接受像`any_char`()或者`end` ($)。该脚本在处理后使用`shift`将它们移走。

其他组接受一两个参数，如`repeat`或`range`。一旦有了定义，这些命令会额外处理它们的参数，这个脚本几乎是反气候的。

## litgrep 脚本

`litgrep`程序有点难以理解，因为它必须确保正确处理空格。该脚本提取参数，直到它读取—作为一个参数，命令行的其余部分转到`grep`。也就是说，您可以在--后面包含`grep`参数和文件名。如果您省略了–,那么`grep`将从标准输入中读取，就好像您在它后面放置了——没有文件参数一样。

如上所述,`${1@Q}`语法确保参数被正确引用。然后在设置 RELIST 时使用`eval`将它以正确的格式放回一起发送给 egrep。

## 动机

多年来，我一直在使用这个工具的不同版本。我的[原始版本](https://www.drdobbs.com/embedded-systems/irregular-expressions/240157655)是用 C++编写的，至少有一个受 C 版本启发的 Python 版本[。](https://benlast.livejournal.com/30871.html)

如果你不知道正则表达式，像这样的工具当然很方便。但是，说实话，你真的应该学习正则表达式。如果你想快速入门，这里有一篇关于 Linux Fu 的文章。或者，碰碰运气，让程序[从数据集中推断出你的正则表达式](https://hackaday.com/2020/04/22/program-guesses-your-regular-expression/)。