# MessagePack 是一个更高效的 JSON

> 原文：<https://hackaday.com/2020/03/12/messagepack-is-a-more-efficient-json/>

这是一个由来已久的问题，即您希望将一些数据存储在某个地方，然后再取回。你如何格式化数据？自定义文件格式并不难，但是如果您使用现有的格式，您可以从库中窃取代码来帮助您。常见的选择包括 XML 或更简单的 JSON。但是，这两个都不是很简洁。这就是 [MessagePack](https://msgpack.org/) 的用武之地。

例如，考虑这个简单的 JSON 节:

```

{"compact":true, "schema":0}

```

这很容易理解，重量为 27 字节。使用 MessagePack，您可以通过使用大于 80 十六进制的字节来通知一些特殊的二进制字段。下面是使用 MessagePack 格式的相同情况:

```

0x82 0xA7 c o m p a c t 0xC3 0xA6 s c h e m a 0x00

```

当然，空格是为了可读性；它们不会出现在现在为 18 字节的实际数据流中。0x82 表示双字节映射。0xA7 引入了一个 7 字节字符串。该图的“真实”部分是 0xC3。然后是一个六字节的字符串(0xA6)。最后，有一个零字节表示零。

你大概能猜出它的大部分。任何以零开头的字节都是固定的整数。从 0x80 开始的数字对贴图进行编码，因此 0x84 是一个四元素贴图。对于数组，前缀是 9 而不是 8，字符串以 0xA0 或 0xB0 开头，因此最多可以轻松编码 32 个字符。

当然，你可能需要一个大于 0x7F 的整数，对吗？因此，还有其他整数格式，如 8 位无符号的 0xCC 或 64 位有符号大端数的 0xD3。0xCA 和 0xCB 的前缀存储 32 位或 64 位 IEEE 754 浮点数。

对于更大的字符串，有 str8 (0xd9)、str16 (0xda)和 str32 (0xdb)。在每种情况下，数字都是字符串长度中的位数。因此，0xd9 获得单字节计数，0xdb 获得四字节计数。当然，还有其他格式，你可以在规范中看到它们。

当然，真正的诀窍是库代码的可用性。该项目声称在他们的网页上有超过 50 种语言。因此，如果你用 C、C++、Haskell、Dart、Kotlin 或 Matlab 编写，你可以找到代码来帮助你。

我们已经看到了大量的 JSON ,而且它可能会继续存在，因为大多数应用程序并不关心表示数据的效率。虽然 XML 因其复杂性已经失宠，[但你仍然会在一些地方遇到它](https://hackaday.com/2018/10/23/slack-on-the-snes-via-satellite/)。