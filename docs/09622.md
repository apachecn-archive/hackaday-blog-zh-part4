# 未记录的 X86 指令允许微码访问

> 原文:[https://hack aday . com/2021/03/26/undocumented-x86-instructions-allow-microcode-access/](https://hackaday.com/2021/03/26/undocumented-x86-instructions-allow-microcode-access/)

对于一个老 CPU 来说，找到所有有效的指令并不困难。你只是尝试了所有的方法。当然，非常老的 CPU 可能很难判断指令做了什么，但是一旦 CPU 遇到非法指令陷阱，您可以快速地扫描可能的操作码，看看什么没有抛出异常。然而，现代处理器完全是另一回事。例如，您可能会运行一条随机指令来锁定机器，或者错过一条本应有效但 CPU 处于错误模式的指令。【Can blük】有一个新颖的解决方案:通过[推测性地执行目标指令](https://blog.can.ac/2021/03/22/speculating-x86-64-isa-with-one-weird-trick/)，然后监控微码定序器，他可以确定 CPU 是否在解码一条指令，即使它拒绝执行这条指令。

一些未知的指令可能有好的或坏的力量，例如最近宣布的[未记录的指令](https://twitter.com/_markel___/status/1373059797155778562)显然可以重写微码。我们希望很快看到一个帖子，介绍如何重新编程您的英特尔处理器，使其本身作为 6502 运行。

推测性执行利用非常聪明。现代处理器无序地执行代码，同时运行指令的不同部分。换句话说，它可能在获取指令 C 的同时存储指令 A 的结果并解码指令 b。问题是当代码可以有条件地分支时，它会引起问题。如果指令 A 是条件跳转，是把 B 和 C 作为下一条指令还是分支地址的指令？无论哪种方式，如果你错了，你需要放弃你已经做的工作，重新开始。

一个答案是简单地停止管道，直到最终决定。不过，这对性能不利。另一种常见的技术是尝试猜测代码中分支的方向，并使用它。这可能是一个简单的试探法，如模式跳转返回，或者它可以保留跳转在过去发生的历史。

关键是代码被部分执行，但是在分支解析之前不能做任何它应该做的事情。通常，这不会有什么帮助，但是观察微码翻译器的性能计数器可以告诉您该指令是生成了真正的低级微码指令，还是被立即删除为坏指令。假设是，如果 CPU 设计者向微码发送指令，它必须做一些事情。[Can]提供了在他的 i7 6850K CPU 上找到的指令列表。

我们喜欢这些对 CPU 架构的深入研究。有时候会导致[神一样的力量](https://hackaday.com/2019/02/03/unlocking-god-mode-on-x86-processors/)，至少在 CPU 层面是这样的。