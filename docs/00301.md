# Hackaday 回答:最高八度音程发生器的故事

> 原文:[https://hackaday . com/2018/08/22/ask-hackaday-answered-the-tale-of-the-top-octave-generator/](https://hackaday.com/2018/08/22/ask-hackaday-answered-the-tale-of-the-top-octave-generator/)

我们从[DC·达森]那里得到了一个问题，他显然有一个 70 年代中期的坏掉的电子琴，需要一个新的顶部八度音程发生器。顶部八度音程发生器本质上是一个集成电路，板上有 12 或 13 个逻辑计数器或分频器，为所讨论的廉价风琴产生一个八度音程的音符，然后一串除以 2 的逻辑计数器将这些音符向下分频，以覆盖键盘的其余部分。由于音板一直发出每个音高，键盘只是一组简单的开关，让声音通过或不通过。很简单，只要你有工作服。

我勇敢地和/或天真地说，我可以在基于 AVR 的 Arduino 上创建一个，尝试过，但失败了。对于这个显而易见的方法来说，时间要求太紧了，所以我把它交给了 Hackaday 社区，因为我有一种挥之不去的感觉，肯定会有人能够迎接这个挑战。

[社区交付！](http://apwizardry.com/?p=4)或者，特别是【Ag Primatic】。通过对这个问题的巧妙处理，一些汇编语言编程，以及可选的 Arduino crystalectomy，[AP]的解决方案非常可靠，没有任何故障，如果您愿意，现在就可以构建一个。我们预计会产生大量劣质的合成器声音。这是一些紧凑的代码。帽子尖！

## 从微控制器中挤出周期

我们来看看[AP]的代码。每当你的微控制器必须按照严格的时间表同时做很多事情，并且在最小的时间增量之间没有足够的 CPU 时间来做很多事情时，[AP]使用的方法非常有用。也许你想无故障地控制十二个伺服电机？或者用[二进制编码调制](https://hackaday.com/2011/07/22/using-binary-code-modulation-to-control-led-brightness/)代替原始脉宽调制来驱动多个 led？然后你会想继续读下去。

[AP]还使用了另外两个技巧:一个是用非整数的计数来伪造周期，另一个是使 AVR 的 ISR 时序绝对无抖动。最后，[Ag]最终用 AVR 汇编语言编写了所有的东西来保证时间，但也很好地包含了一个 C 清单。所以，如果你想尝试组装，这是一个好的开始。

简而言之，如果您在有限的微控制器资源上做任何有严格时序要求的事情，尤其是 AVR，请继续阅读！

## 花时间思考

[![](../Images/c405a48f9acdefe874f44a57577c8334.png)T2】](https://hackaday.com/wp-content/uploads/2018/08/scope_252.png)

最高倍频程发生器的目标是获取一个输入时钟，并将其分成 12 个同时运行的子时钟，这些子时钟彼此独立运行。需要明确的是，这意味着以 1 MHz 左右的频率在 0 到 12 个 GPIO 引脚之间更新——以 AVR 的最大 CPU 速度每二十个时钟周期更新一次。如果你认为你可以遍历 12 个计数器，并决定在 20 个周期内翻转哪些引脚，那你就错了。

但是认识到问题是解决问题的第一步。虽然最严格的时间表可能要求一个引脚在翻转另一个引脚后恰好 20 个时钟翻转，但大多数情况下，引脚更新之间会有更多周期，从数百个到数千个不等。因此，解决方案是识别何时有时间思考，并利用这段时间预先计算一个装满下一个状态的缓冲区。

[![](../Images/79a932d265b7ab162c48ba805e60eae9.png)](https://hackaday.com/wp-content/uploads/2018/08/assembly.png)【Ag】的解决方案使用几个不同的循环，每个正好运行 20、40 和 60 个周期——更长的版本只是用 [`NOP` s](https://en.wikipedia.org/wiki/NOP) 填充的 20 个周期。这些循环运行在中断服务程序(ISR)中。当在下一个预定的管脚改变之前有 80 个或更多的思考时间周期时，控制返回到主循环，并且下一个中断被设置为在下一个必要的更新时间重新进入紧密循环。

快速循环所要做的就是读取两个字节，将它们写入 GPIO 引脚，将指针递增到下一行数据，并确定它是否需要再暂停 20 或 40 个周期，或者将 ISR 定时器设置为更长的延迟，然后返回计算。这可以在 20 个周期中的 12 个周期内完成！滑头。

## 缓冲

从最高八度音程发生器的细节上退一步，这是一个经典的问题和经典的解决方案。值得你花时间去内化它，因为你会在任何有实时约束的时候遇到这种情况。问题是平均来说*有足够的时间来完成计算，但是在最坏的情况下*这是不可能的。所以你把问题分成两部分:一部分尽可能快地运行，另一部分进行快速部分需要的计算。将快速和慢速过程联系在一起正是计算机科学给了我们[缓冲器](https://hackaday.com/2015/10/29/embed-with-elliot-going-round-with-circular-buffers/)的原因。**

 **在[AP]的代码中，这个缓冲区是一个表，其中每个条目有两个字节用于 12 个 GPIO 引脚的状态，一个字节用于存储延迟到下一次更新的时钟周期数。另一个字节为空，整个表有 64 个条目或 256 个字节。为什么是 256 字节？因为 AVR 有一个 8 位无符号整数，所以从表的末尾返回到开头是自动的，节省了几个浪费的`if`语句周期。

但即使有了这种快/慢分工，也没有多少时间剩下来做预计算了。用 20 MHz 的 CPU 时钟在钢琴键盘 (4186 Hz)上发出最高 C 音需要每 2390 个周期切换一次 GPIO 引脚，所以这是 CPU 能看到的最长时间。当虚拟振荡器异相时，这可以短得多。通过以 20 MHz 全速运行 AVR，并对汇编中的所有内容进行编码，[AP]可以足够快地运行计算，以支持 12 个振荡器。在 16 MHz 时，只有十倍的时间，所以每个小的优化都很重要。

## 需要一些优化

或许[AP]所做的最聪明的优化之一就是让这一切成为可能。最初的 top-octave 芯片通过一组精心选择的整数除数对 2 MHz 方波进行分频。以 2 MHz 的分辨率运行 AVR 等效电路意味着每次更新只需要 10 个时钟，而[AP]的 fast 例程需要 12 个时钟，因此更新速率必须减半。但这意味着原始 IC 上的一些奇数除数在 AVR 代码中会变成非整数。例如，最高 C 在硅中再现为 2 MHz / 239，因此要在 1 MHz 下实现这一点，需要在整数 CPU 上计数到 119.5。如何应对？

你可以想象一半时间数到 119，另一半时间数到 120。没有人会注意到占空比的微小差异，音高仍然会准确无误。我心中的 C 程序员会想编写这样的代码:

```

uint8_t counter[12] = { 0, ... };
uint8_t counter_top[12] = { 119, ... };
uint8_t is_counter_fractional[12] = { 1, 0, ... };
uint8_t is_low_this_time[12] = { 0, ... };

// and then loop
for ( i=0 ; i&lt;12; ++i){
  if ( counter[i] == 0 ){
    if ( is_counter_fractional[i] ){
      if ( is_low_this_time[i] ){
        counter[i] = counter_top[i];
    is_low_this_time = 0;
      else {
        counter[i] = counter_top[i] + 1;
    is_low_this_time = 1;
      }
    }
  }
}

```

这是可行的，但是需要评估时间。相反，[美联社]做了同样的事情:

```

uint8_t counter[12] = { 0, ... };
uint8_t counter_top[12] = { 119, ... };
uint8_t phase[12] = { 1, 0, ... };

for ( i=0 ; i&lt;12; ++i){
  if ( counter[i] == 0 ){
    counter[i] = counter_top[i] + phase[i];
    counter_top[i] = counter[i];
    phase[i] = -phase[i];
  }
}

```

这种结构的特别之处在于，它不需要区分代码中的整数和非整数延迟。交替地从非整数值中加 1 和减 1 可以解决“一半”的问题，而将`phase`变量设置为 0 意味着整数值的除数不加修改地运行，没有`if` s。

最终的优化显示了[AP]在使这个 AVR 最高倍频程发生器像真正的 IC 一样工作方面走了多远。在 ISR 中设置定时器重新进入快速循环时，可能会出现一个周期的抖动。由于 AVR 指令在一个或两个时钟周期内运行，因此当 ISR 定时器到期时，可能会运行两个周期的指令。根据运气，中断将在 4 或 5 个时钟后运行:详情参见 AVR 数据手册中的“中断响应时间”部分。

在 ISR 的序言中，[AP]的代码会仔细检查硬件计时器，看它是否进入了一个单周期指令，并添加一个额外的 NOP 进行补偿。这使得产生的振荡器几乎没有抖动，可能会产生 50 ns(20 MHz 时一个周期)的斜坡。我不认为您能够听到这种抖动，但结果在示波器上看起来肯定很漂亮，这可能是一个有用的技巧，可以知道您是否曾经用 ISR 进行过超精确定时。

## 布丁的证据

自然，我必须在真实的硬件上测试这些代码。第一步是从壁橱里取出一个随机的 Arduino 克隆体，并把它闪存进去。因为“Arduinos”在 stock crystal 上以 16 MHz 运行，所以结果是名义上 440 Hz 的音乐会 A 演奏得更像一个稍微高一点的 F，一个音乐三度音。它本身听起来很好，但你不能和任何其他调到 440 赫兹的乐器一起演奏。

[AP]的首选解决方案是在 20 MHz 下运行 AVR 芯片。由于硬件要求非常适中，你可以使用一个 0.50 美元的 ATTiny816 和一个 20 MHz 的晶体，并且你会有一个顶部八度音程发生器用于字面上的口袋变化——当然比购买一个 Arduino 克隆更便宜。我在试验板上用 ATMega48P 和 20 MHz 的晶体进行了测试，因为这是我所拥有的。或者你可以对你的 Arduino 进行水晶切割，让它全速运行。

我们通过电子邮件反复讨论所有其他(固件)选项。[美联社]都试过了。您可以将 ISR 减少到 16 个周期，以 16 MHz 运行，但是主循环中的 CPU 时间只够支持 10 个音符，比全八度差两个。你可以尝试 1 MHz 以外的其他更新速率，但除数最终会变得相当不稳定。引用[AP]我们关于该主题的电子邮件讨论:

> 在使用原始顶部倍频程发生器 IC 的分频器值并尝试不同的基频后，2 MHz 的更新速率似乎是获得合理整数分频比的最佳点，误差小于+/-2 美分。芯片的最初设计者一定也做了同样的计算。”

要制作一个完整的风琴，你还需要 12 个二进制计数器芯片来划分每个音符，以填充键盘的低位寄存器，但这些很容易设计，每个只需要几十美分。总而言之，多亏了[AP]极其聪明的编码，你可以以不到 10 美元的价格建造一个完全复音的噪音制造器，它可以同时发出 96 个音调，而且都是合拍的。这真是太神奇了。

当然，我已经基于这段代码构建了一个小设备，但这是另一篇文章的主题。未完待续。**