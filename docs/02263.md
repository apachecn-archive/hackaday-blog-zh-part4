# “好的代码文档本身”和其他你不应该告诉自己的搞笑笑话

> 原文:[https://hacka day . com/2019/03/05/good-code-documents-self-and-other-poppy-journey-you-should-tell-you-you-not-you-tell-you-self/](https://hackaday.com/2019/03/05/good-code-documents-itself-and-other-hilarious-jokes-you-shouldnt-tell-yourself/)

代码文档——还有比花时间写大量注释更令人兴奋的事情吗？如果让我猜的话，你的答案可能是“嗯，是的，*一切都比那更令人兴奋”。此外，请求记录您的代码几乎就像是对您深思熟虑的设计的侮辱，您如此小心地实现的这个美丽的创造，它只是必须显而易见发生了什么。写这些只是多余的，你需要的只是代码。*

因此，无论是一些开源项目还是专业软件开发，代码文档通常有两种味道:不存在和无用。任何领域或语言的程序员都不喜欢记录自己的代码，无论他们身在何处。这是可以理解的，毕竟，你是为了编码，实现所有有趣的东西。如果你想讲故事，你会选择一条不同的人生道路。

这种不情愿甚至形成了全新的范式和哲学，声称评论实际上是有害的，任何试图逃避评论的人现在都可以愉快地重复这些说法。但是，夸张一点说，我们本质上是在用这种方式将信息丑化。诚然，评论可能会适得其反，但更多的是对它们的基本态度造成了伤害。

最后，代码文档很像[错误处理](https://hackaday.com/2019/01/22/crash-your-code-lessons-learned-from-debugging-things-that-should-never-happen/)，我们很早就被告知它的重要性和必要性，但我们无法理解为什么，相反，我们越来越讨厌为同一个老老师、主管或讨厌的队友再做一次。但是就像错误处理一样，如果做得正确，我们才是真正从中受益最多的人。但是为了把它做好，我们需要面对一些严酷的事实，并开始承认不存在自文档化代码这种东西，如果我们不能设法写一些关于它的话，也许我们根本不明白我们实际上在做什么。

所以让我们来戳破一些泡沫吧！

## 自我记录的代码不存在

反对注释代码的通常论点是“代码应该写得很好，不需要任何进一步的解释”，如果我们谈论的是代码做什么，这实际上很难反驳。写得好的代码确实不需要任何注释来描述变量或函数的目标是什么。

```

// bad start:
int a = 4 * OFFSET;
// but don't use a comment to tell what it does:
int a = 4 * OFFSET; // initial foo value
// instead choose a name telling it itself:
int initial_foo = 4 * OFFSET;

```

是的，一个有意义的变量名会使注释过时，但这与其说是关于文档，不如说是一个体面的编码风格的问题。当这种容易证明的片面观点成为反对任何类型评论的普遍理由时，问题就开始了，包括那些超出解释*什么*的评论，并专注于实际有趣和有帮助的部分。

问题是，为你的变量、方法、类、函数、模块等等起一个不言自明的名字。并不能自动描述代码的全貌，也不一定能告诉我们关于*为什么*和*以什么方式*部分的更多信息。然而，拥有一个清晰且编写良好的实现往往会给人一种错觉，即也不需要这样做。是的，在花了几个小时或几天的时间思考手头的问题后，当然这些代码在那一刻会非常有意义，如果您将它们整齐地打包到一个合理大小的提交或拉取请求中，以一种简洁和连贯的方式呈现您的解决方案，就更有意义了。

但是一个月后呢？还是在自包含提交的上下文之外？或者以稍微改变的心态去接近它？你会记得多少细节，那时这一切还有多少意义？

## 软件很难

当然，人们可以(也将会)争辩说“代码就在那里，只要读一读你就知道了”，同样，如果我们谈论的是某个特定代码块做什么，那么是的，这种态度是有道理的。但除此之外，钻研代码是不必要的时间浪费，本质上就像说一本书不需要索引，只要读完整本，你最终会找到你要找的东西。你真的想在头脑中分析一些数据可能经过的每一条路径，以找出其有效范围吗？而一个只需要花几分钟来写甚至更短时间来读的句子就可以直接告诉你答案了。

这不仅仅是理解别人的代码，或者向别人解释你在想什么。你有多少次发现自己想知道当你重温旧代码或修复一个 bug 时你到底在想什么，或者惊讶于一个`git blame`暴露了你自己的名字？然而下一次，一切都被遗忘了，你会再次确信一切都是不言自明的，所有的细节都是明白无误的。

无论你如何努力，软件本身并不是完全通用的自文档化。这既不是你的错，也不是我试图成为一个恶霸并质疑你的能力，但这只是关于人类，关于低估软件的全部复杂性和我们思想的易变性。文档不是羞辱和指出你的实现中的缺点，而是反击编程语言本身的缺点。即使是曾经编写过的最干净的代码也不能自己解释你在写它的时候到底在想什么。一切可能都很完美，但仍然会做错事。注释不是编写干净代码的替代品，而是它固有的一部分。

## 评论剖析

在深入讨论细节之前，我们先来看看不同的评论风格。

```

/**
 * Javadoc-style documentation comment.
 */
void foo(void) {
    if (bar > 10) {
        /* regular comment */
        ...
    }
}

```

常规注释就是:由语言本身定义的注释。根据经验，应该尽量少用它们，因为它们倾向于解释*代码正在做什么*。

另一方面，文档注释用于从外部的角度描述全局变量、函数和模块(以及它们的面向对象的对应物)。在函数体内，它们基本上变成了常规注释，工具通常会忽略它们。作为一个好的实践，如果在函数内部有一些值得讲述的东西，看看它是否能被处理到函数描述本身中。

文档注释本质上是带有一些额外附件的常规注释，比如一个额外的正斜杠`/// doc comment`、感叹号`//! doc comment`或`/*! multiline doc comment */`，或者一个额外的星号，如 Javadoc 风格的注释`/** doc comment */`。尽管名称如此，Javadoc 作为一种注释样式也受到其他语言和工具的支持，并将在这里的例子中使用。

当然，你也可以只使用普通的注释，完全忘记那些奇怪的标签，但是好处是文档生成器，比如 [Doxygen](http://www.doxygen.nl/) 或者 [Sphinx](http://www.sphinx-doc.org/) 可以直接从文档注释中轻松地创建 pdf、HTML 或者手册页，并且大多数现代的 ide 都有额外的支持来显示它们，这样可以省去你在心理上切换到实际实现的麻烦——前提是有一些有用的信息。

但是除了触发评论后处理器，评论的格式并不重要。重要的是你在说什么。

## 多余的评论集中在错误的信息上

因此，我们已经确定，我们不应该记录代码做了什么，而是记录 T2 为什么做，T4 以什么方式做，但是这到底意味着什么呢？

人们讨厌记录他们的功能的一个常见原因是“他们只是陈述显而易见的事情”，因此是多余的。阅读一般的文档注释，实际上很难反驳这一点，尤其是当涉及到面向对象语言的封装时。一些简单的`get_temperature()`函数的一般描述可能是这样的:

```

/**
 * Returns the temperature.
 */
int get_temperature(void) {
    return temperature;
}

```

那个注释确实没有增加多少价值，它本质上只是重复了函数的名字，因此只告诉了*它做了什么*。这不是我们想要的。我们想要的是代码没有告诉我们的细节。

很容易认为整个函数就是这么简单，绝对没有什么有用的东西可以在第一时间评论。但是话说回来，在软件中没有什么是真正简单的，如果你足够仔细地观察，你会发现每一个函数都有一些值得写的东西，从它的名字，甚至是一个简单的一行程序的代码来看，这并不是显而易见的。

```

/**
 * Returns the temperature in tenth degrees Celsius
 * in range [0..1000], or -1 in case of an error.
 *
 * The temperature itself is set in the periodically
 * executed read_temperature() function.
 *
 * Make sure to call init_adc() before calling this
 * function here, or you will get undefined data.
 */
int get_temperature(void) {
    return temperature;
}

```

事实证明，这个看似简单但虚构的函数毕竟有很多额外的信息要写。不是因为简单，而是因为简单。仅仅从代码来看，没有任何信息是显而易见和不言自明的，包括关于内部数据处理和程序流的附加信息。当然，深入挖掘代码最终会揭示出相同的信息，但同时也会浪费大量时间，更不用说可能需要的不必要的脑力劳动了。

其他人可能会说，这些是实现细节，在文档中没有位置。但是为什么呢？为什么您不想陈述那些特定于实现的细节，以便最终更容易理解发生了什么呢？

采取这样的心态，即每个功能都有一些东西要讲，总有至少一个细节、副作用、例外、限制等等。值得一写，意味着你可能需要从不同的角度去寻找它。为了能够做到这一点，你不可避免地要越来越多地面对代码中隐藏的细节，可能会发现你以前从未想到过的死角。因此，文档不仅有助于未来的读者理解代码，也有助于作者更好地了解其内部细节。

如果你真的找不到任何有用的信息来添加，你也许应该问问自己为什么代码会在那里。拥有它的正当理由是什么？这个理由就是要添加的信息。前面的例子可能会有不同的方向:

```

/**
 * Returns the temperature.
 *
 * This is for testing purpose only and should
 * never be called from a real program.
 */
int get_temperature(void) {
    return temperature;
}

```

请注意，这仍然是与之前完全相同的代码，这给我们带来了另一个“看似不言自明的代码太简单而无法评论”的问题:它可能模糊不清，导致错误的假设和可能的 bug。从代码质量的角度来看，指出这些细节并消除潜在的歧义是至关重要的，可以说这实际上使文档成为了代码本身的重要部分。

同样，每个函数都有一些东西要告诉我们，但如果不深入研究代码，这些东西并不明显。自然地，一些不显眼的细节比另一些更相关，并且不是一个函数必须告诉的所有事情都是有趣的。但是真的有信息太多这样的事情吗？认知偏见的清单很长，仅仅因为某件事在这个特定的时刻对你来说是显而易见的，并不意味着对下一个处理你的代码的人也是如此——包括你未来的自己。

## 让注释成为代码的一部分

现在是抛出另一个最喜欢的“注释是不好的”说辞的好时机:当代码改变时，它们就过时了。让我们现实一点，这只是一个非常懒惰的借口，它不像代码通常是写了很多考虑是否在将来再次接触它。一旦提交和合并，代码就是最终的和完美的，永远保持原样。

代码文档更大的问题是，它被视为存在于实际代码之外的东西，与实际代码完全分离。但是，如果我们开始将它视为代码的实际部分，一个补充实体，而不是对任何无法处理实际问题的人的一些简化总结，那么每当代码发生变化时，简单地调整它就会变得很自然。

是的，这包括 C 中的私有方法和 [`static`代码。声称它们包含不需要文档的不相关的实现细节，或者无论如何不向代码的“消费者”公开，这是一个很大的误解。如果我们考虑库、API 等的用户，至少后一部分可能是正确的，但是开发者呢？毕竟，私有函数通常是所有有趣的细节发生的地方，数字运算、数据处理、所有小秘密——以及通常需要最多维护的部分。](https://hackaday.com/2015/08/04/embed-with-elliot-the-static-keyword-you-dont-fully-understand/)

范围应该与信息的相关性或存在性无关，但这只是表明了对代码文档的一般心态是如何将其视为除了我们自己以外的任何人的事情。

## 打破循环

没有人喜欢糟糕的文档，但是完全避免文档并不能解决问题。修复开发人员和注释之间的不正常关系是改善这种情况的唯一方法，将它们视为与代码共存的基本部分是良好的第一步。

毫无疑问，这需要实践并习惯这种思维方式，但从长远来看，这只会有利于对代码的总体理解和质量。

本着这种精神，这里有最后一个多余的评论:

```

/* You have reached the end of the article */

```