# FPGA 测试平台变得更加简单

> 原文:[https://hack aday . com/2018/11/16/FPGA-test benchs-made-easy/](https://hackaday.com/2018/11/16/fpga-testbenches-made-easier/)

你终于写完了令人惊叹的新 DSP 功能的 Verilog，它将彻底改变人类社会，让你变得富有。有用吗？当然，你的第一反应是把它吹进你选择的 FPGA，看看它是否能工作。如果是的话，那真是个好主意。如果没有，这是一个糟糕的想法，因为通常很难看到 FPGA 的内部。这就是为什么在将逻辑提交给 FPGA 之前，通常要在台式计算机上模拟逻辑。但这意味着你必须延迟满足足够长的时间来编写一个测试平台——一段硬件描述语言(HDL)代码，来执行你编写的功能。在这篇文章中，我将向您展示一个小软件，它可以读取您的 Verilog 模块，并自动为您创建大部分测试平台。代码最初来自于 [GitHub](https://github.com/xfguo/tbgen) ，但是我想对它做一些改变，所以[我分叉了它](https://github.com/wd5gnr/tbgen/tree/master)，我会告诉你我所做的改变。这并不特定于特定的 FPGA。任何 Verilog 项目都可以使用该工具来生成一个简单的入门测试平台。

编写测试平台并不难。你通常使用与编写原始代码相同的语言，但由于它不会驻留在芯片中，你可以在模拟器中做你将合成的代码中无法完成的事情。然而，总是不得不编写或多或少相同的代码是有点痛苦的，尤其是如果您有许多想要测试的模块。但是在将小模块链接在一起之前测试它们，然后再将它们链接在一起，这是一个好主意。使用这个小 Python 脚本，很容易生成一个简单的测试平台，然后进一步完善它。这不会改变生活，但确实节省了一些时间。当然，如果您想尝试一下，您需要一些东西来运行 Python 脚本。你还需要一个 Verilog 模拟器，或者你可以使用 [EDA Playground](https://hackaday.com/2015/07/21/learn-fpgas-in-your-browser/) 在你的浏览器中尝试这一切。

## 测试平台的剖析

Verilog 测试平台通常有几个主要部分:

1.  没有输入或输出的模块。这就像一个 C 程序的主要功能。
2.  Reg 变量，用于输入到被测设备的所有输入。
3.  要监控的设备或被测设备的所有输出的接线变量。
4.  初始化所有 reg 变量的初始段。
5.  由于被测设备可能需要一个时钟，一个 always 块或一个 forever 循环将在一个 reg 变量中创建时钟。
6.  由于被测设备可能需要复位，所以通常会产生一个复位信号。
7.  您将需要向 Verilog 模拟器发送一些特殊的命令，要求它监控某些信号并将它们记录到一个文件中。您也可以只打印诸如通过/失败消息之类的东西，但是通常您想要一个带有信号跟踪的文件。
8.  然后，您将向被测设备发送您想要的任何输入向量，在信号转换之间放置适当的时间延迟。

Verilog 模拟器有两个特性可以实现这一点。首先，在测试平台的开始有一个时间刻度语句，告诉模拟器每个“刻度”代表什么，以及刻度有多精确。例如，您可能有``timescale 1ns/100ps`，这意味着延迟 1 表示 1 纳秒，对于 1.1 和 1.2 纳秒的延迟有足够的分辨率。相比之下，``timescale 1ns/1ns`只有 1 ns 的分辨率。如果您写下 1、1.1 和 1.2 纳秒延迟，它们将被四舍五入为相同的 1 ns 延迟。当然，延迟不能在针对 FPGA 的代码中使用，但在仿真中，它们是公平的游戏。

因此，举例来说，如果你想断言一个 5 纳秒的信号(给定上面的时间刻度),你可以写:

```

reg thesignal=0;

...

thesignal=1'b1;

#5 thesignal=1'b0;

```

[![](../Images/0b46c7c51db53c0c79832897643f10e4.png)T2】](https://hackaday.com/wp-content/uploads/2018/09/sig.png)

## 一个示例测试平台

有了这些，让我们进入一个简单的测试平台。如果你好奇的话，测试中的设备并不重要，尽管它是在 [GitHub](https://github.com/wd5gnr/tbgen/blob/master/top.v) 上的例子。我要把它分成几块:

```

`timescale 1ns/1ns //Adjust to suit

module tb_top;

```

这是时间刻度和没有 I/O 的模块。下一节将介绍被测设备的输入和输出变量。

```

reg clk ;
reg rst ;
reg run ;
reg hold ;
wire LED1 ;
wire LED2 ;
wire LED3 ;
wire LED4 ;

```

这里是您创建想要测试的模块的地方。UUT 代表被测单元。

```

top uut (
.clk ( clk ),
.rst ( rst ),
.run ( run ),
.hold ( hold ),
.LED1 ( LED1 ),
.LED2 ( LED2 ),
.LED3 ( LED3 ),
.LED4 ( LED4 )
);

```

时钟的周期将是 10 纳秒。

```

parameter PERIOD = 10; //adjust for your timescale

```

这段代码将设置输出文件，设置我们想要查看的内容，并生成时钟。$dumpvars 语句告诉模拟器从 tb_top(这个模块)开始，一直到层次结构中的下一层。

```

initial begin
   $dumpfile(&quot;tb_output.vcd&quot;);
   $dumpvars(2, tb_top);
   clk = 1'b0;
   #(PERIOD/2);
   forever
    #(PERIOD/2) clk = ~clk;
end

```

我通常使用一个 always 块来生成时钟，但是像这样的永久循环也可以。你不能在它后面放任何东西，除了结尾，因为循环从来不存在。但正如你在下面看到的，它工作得很好。

[![](../Images/82e79abd9f07a08e7cf9bfc520a01670.png)T2】](https://hackaday.com/wp-content/uploads/2018/09/wave.png)

这个小片段处理复位信号。注意复位信号是负的，你只需要改变第一个零点。

```

initial begin
   rst=1'b0;
   #(PERIOD*2) rst=~rst;
   #PERIOD rst=~rst;
end

```

最后，我们初始化设备输入，等待一段时间等待复位建立，然后给它一些测试输入。等了一会儿后，我们调用$finish 来停止整个过程。

```

initial begin
   run=1'b0;
   hold=1'b0;
   #(PERIOD*10) run=1'b1;
   #PERIOD run=1'b0;
   #(PERIOD*1024) hold=1'b1;
   #PERIOD hold=1'b0;
   #(PERIOD*100)
   $finish;
end

endmodule

```

## 自动化

我在 GitHub 上找到的原始 Python 程序完成了大部分工作。然而，很多东西都是硬编码的，虽然它检测到了复位信号，但它没有做任何事情。更何况它不仅没有行使复位，而且也没有给你做任何的测试信号，这是可以理解的。但是，如果您对文件进行了更改，然后想要重新生成测试平台(可能您的模块更改了它的输入和输出)，您将会丢失您的更改！

我分叉了代码，并将其更改为用 Python 3 运行，添加了命令行选项，然后对 pulse reset 做了一些更改。为了处理您的添加，测试平台包括一个文件，您可以使用它来编写自己的测试代码。这样，重新生成测试平台就不会破坏您的代码。

这些都是很简单的改变，但都有回报。如果您不使用选项，您会得到合理的默认值。但是，您可以指定以下任意或所有选项:

*   -d–设置自定义转储文件名
*   -I–设置自定义用户包含文件
*   -l–设置转储变量级别
*   -p–设置周期
*   -r–将复位设为低电平有效
*   -t–设置时间刻度

所以在上面的例子中，最终的初始块会出现在用户包含文件中，因为脚本没有生成它。其余的都是工具的自动输出。

## 尝试

在我的项目分支中有一个示例模块 top.v。实际上，你可能以前在关于嵌入逻辑分析器的[帖子中见过这个，但是现在，我减少了时间延迟以使它更容易模拟。这并不罕见，因为 12 MHz 下的 1 秒延迟需要 1200 万个时钟周期。](https://hackaday.com/2018/11/09/x-ray-vision-for-fpgas-using-verifla/)

这一点的缺省值很好，所以发出如下命令:

```
./tbgen.py top.v tb_top.v
```

当然，你不需要。/如果可执行文件在您的路径上。现在需要模拟 tb_top.v 文件。我已经提供了用户 include (user.tb_top.v)，但是如果您是从零开始，那么您必须创建那个文件，即使它是空的。这是保存您要执行的特定测试的文件。

如果您使用 Icarus，您的模拟可能如下所示:

```
iverilog tb_top.v top.v -o tb_top
vvp tb_top
gtkwave tb_output.vcd
```

如果你不想装什么，可以试试 EDA 游乐场。只需将测试平台文件放在左侧窗格中，将顶部模块放在右侧窗格中。您需要将用户包含文件粘贴到 include 语句上，或者创建一个新的测试工作台选项卡并放在那里。我已经为你做好了，如果你想看一眼的话。

## 值多少钱？

像大多数工具一样，如果您知道如何不使用该工具，这种方法效果最好。尽管很方便，但是您仍然需要了解一些关于测试平台的事情来使它工作。另一方面，不必为多个模块一遍又一遍地创建相同的代码，这是一个很好的时间节省。这也使你的测试代码更加一致。如果您不喜欢生成的代码，即使您不是 Python 向导，也很容易进行修改。我考虑过改变代码，从一个模板文件开始工作，但是它很好。然而，我并不是一个善罢甘休的人，如果你想试试的话，我有一个版本可以从 [GitHub](https://github.com/wd5gnr/tbgen/tree/template) 的模板分支中的模板文件中读取。

你可能会说，你不想模拟你的 Verilog，相反，你宁愿把一个逻辑分析仪放在板上，并在实际的硬件上调试。这在理论上听起来很棒，实际上我会在以后的文章中告诉你怎么做。但是也有问题。除非你的设计非常简单，否则你通常不能在逻辑分析仪中得到所有的东西。重新配置可能是一个漫长的过程，你并不总是有能力设置你需要的确切刺激。模拟是一种“上帝模式”，你可以让任何事情发生，看到一切。当然，模拟也有它自己的问题，尤其是行为模拟，在这种模拟中，你不能考虑真实的时间延迟之类的事情。因此，我认为虽然板载逻辑分析仪是一个很好的工具，但它不能取代模拟，就像模拟不能完全取代现场调试一样。

同时，使用这个工具可以帮助你创建你的测试平台。阅读它生成的代码可以帮助您学习如何创建自己的代码，即使您不想在所有情况下都使用该工具。