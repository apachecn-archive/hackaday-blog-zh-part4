# UEFI 是怎么回事？

> 原文：<https://hackaday.com/2021/11/30/whats-the-deal-with-uefi/>

似乎有两个阵营，一小群人关心 UEFI，另一群人只要他们的电脑正常工作就不会真正注意或关心。所以我们来谈谈 UEFI 是什么，它是怎么来的，它适合做什么，以及为什么你应该(或不应该)关心它。

## UEFI 是什么？

UEFI 代表统一可扩展固件接口，是由一个名为 United EFI Forum 的组织持有的标准。英特尔推出了 EFI(可扩展固件接口),后来将该规范公开为 UEFI。作为一个规范，供应商和制造商之间的实现细节有所不同，但目标是提供一个 OS 引导加载程序的标准和可理解的结构。这使得编写操作系统变得更加容易，因为你不再需要担心实际启动芯片组的所有麻烦事。

几个 IBV(独立 Bios 供应商)提供了他们的 UEFI 实现，生产主板的 OEM 可以许可并在他们的产品中使用。例如 AMI、Phoenix 和 InSyde。在您选择的操作系统正确启动之前，您可能已经看到他们的徽标或只是他们名字的文本在屏幕上短暂闪现。

先说 UEFI 靴子如何。通常，有几个不同的阶段。我们通常会说，因为有许多实现，而且它们中的许多都不符合规范。有[三个一般阶段](https://edk2-docs.gitbook.io/edk-ii-build-specification/2_design_discussion/23_boot_sequence) : 安全(秒)、预 EFI 初始化(PEI)、驱动执行环境(DXE)。每一个都是迷你操作系统。因为英特尔是 EFI 的创始人，后来又将其转变为 UEFI，所以大部分设计都是围绕着英特尔处理器的启动方式进行的。ARM 等其他平台在 SEC 或 PEI 阶段可能不会有太大作为。

X86 处理器的引导过程有点奇怪。出于向后兼容的原因，它们以[实模式](https://en.wikipedia.org/wiki/Real_mode)(尽管目前大多数处理器在技术上是不真实的)开始，具有 20 位地址空间(1MB 的可寻址存储器)。随着处理器继续启动，它切换到[保护模式](https://en.wikipedia.org/wiki/Protected_mode)，然后最终切换到[长模式](https://en.wikipedia.org/wiki/Long_mode)。在多核系统中，所有处理器都竞相获取信号量或读取 EAX，其中一个被指定为 BSP(引导处理器)。失败者都暂停，直到 BSP 通过 IPI(处理器间中断)启动它们。通常，片上有一个 SPI 闪存芯片，固件映射到物理 32 位存储器区域的末端。英特尔管理引擎(ME)或 AMD 平台安全处理器(PSP)执行 SEC 阶段的大部分工作，例如刷新缓存和启动处理器。

一旦处理器启动，PEI 就正式开始了。在 Intel 系统上，大多数 PEI 中没有系统 RAM。这是因为在处理器可以使用链接之前，需要对内存进行训练并对链接进行初始化。对 RAM 越来越快速度的不懈追求意味着 RAM 需要在每次启动时进行测试、校准和配置，因为不同的 RAM 棒具有其他参数。许多系统缓存这些参数以加快引导速度，但随着 RAM 老化，这些参数通常需要失效并重新训练。在主 x86 处理器退出重置之前，PSP 在一些 AMD 系统上处理内存训练和加载 UEFI。对于英特尔系统，他们使用一种称为 XIP(就地执行)的技巧，将各种缓存变成临时 RAM。只有一个很小的堆栈，很小的堆空间，没有用于 PEI 的静态变量。许多英特尔服务器平台依靠主板管理控制器(BMC)来训练内存，因为训练大量内存需要很长时间。

在初始化 RAM 并转移临时缓存的内容后，我们转移到 DXE。DXE 阶段提供两种类型的服务:引导和运行时。运行时服务是指由操作系统消费的服务，如非易失性变量。一旦调用 ExitBootServices(通常由 OS 加载程序调用),引导服务就会被破坏，但它们是像键盘输入和图形驱动程序这样的服务。BDS(引导设备选择)在 DXE 运行，它是系统决定引导什么驱动器(硬盘、USB 等)的方式。).

这是一个非常密集且特定于 x86 的概述。ARM 等许多架构都避开 UEFI，转而采用更类似于 [coreboot](https://www.coreboot.org/) 、linuxboot 或 LK 的东西，它引导一个小的 Linux 内核，然后由 kexec 引导成一个更大的内核。然而，许多 ARM 平台也可以利用 UEFI。只有时间能告诉我们这个行业的走向。

## 它是如何产生的

2005 年，UEFI 完全取代了 EFI(可扩展固件接口)，这是英特尔几年前提出的标准。EFI 借鉴了那个时期 Windows 的很多东西，PECOFF 图像格式，UEFI 反过来也借鉴了 EFI 的做法。在 EFI 之前，有很好的老 BIOS(基本输入输出系统)。该名称源于 1975 年的 CP/M 系统。在那个时期，BIOS 是系统引导的一种方式，并通过提供 [BIOS 中断调用](https://en.wikipedia.org/wiki/BIOS_interrupt_call)为应用程序提供某种程度上统一的接口。这些调用允许程序访问输入和输出，如串行端口、RTC 和 PCI 总线。菲尼克斯和其他人对 IBM 为制造 IBM 兼容机器而创建的专有接口进行了逆向工程，最终导致了接近标准的东西。

## 比 BIOS 好吗？

是也不是，取决于你的观点。许多操作系统供应商喜欢 UEFI，因为他们通常使他们的生活更容易，因为所提供的服务使得提供同质的引导体验变得容易。总的来说，Linux 社区对 UEFI 持不可知论者的态度，持敌对态度。截至本文撰写之时，BIOS 界面已经推出 45 年了，从各方面来看，它都被认为是一种遗产。UEFI 的另一个优点是，它方便了选择不同的引导设备和更新机器上的固件。UEFI 在主引导记录(MBR)上使用 GUID 分区表(GPT)——被认为是 MBR 不太灵活的一个优点。今天发布的许多平台都基于来自 TianoCore 的开源 EDK2 项目，它是 UEFI 的一个实现，支持 X86、ARM 和 RISCV。

对 UEFI 最大的抱怨是，它是一个封闭的黑匣子，可以不可想象地访问你的计算机，并在计算机启动后驻留。BIOS 很有吸引力，因为它的接口是众所周知的，并且通常是非常驻的。UEFI 可以更容易地更新，但也有更重要的更新需求。UEFI 更新可以彻底摧毁你的系统。它将无法启动，并且由于单元上的保险丝被烧断，即使对于制造商来说，实际上也几乎不可能修复它。对这些更新进行了大量的测试，但由于工作量大，大多数人都不愿意推出很多更新。

## 为什么你应该或不应该关心

在一天结束的时候，你关心的是你是否能用你的电脑做对你来说重要的事情。无论是玩游戏，写邮件，还是制造一台新电脑，只要电脑做你想做的，都没关系。启动只是实现这一目标的一个经常被遗忘的步骤。如果你想知道你的机器运行的每一段代码，你需要开始一段漫长的旅程。像 [Librem 这样的公司竭尽全力确保像内存初始化这样的棘手问题在非专有 blobs 中运行。你仍然可以调整 UEFI，【黑尔斯】](https://edk2-docs.gitbook.io/edk-ii-build-specification/2_design_discussion/23_boot_sequence)[是一个调整旧学校笔记本电脑 BIOS 的好例子](https://hackaday.com/2021/08/23/school-surplus-laptop-bios-hacked-to-remove-hardware-restrictions/)。用于检查和理解幕后发生的事情的开源工具越来越好。

最终，这取决于你是否关心你的设备的启动过程。