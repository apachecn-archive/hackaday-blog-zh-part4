# Bash 管道难题:绿色、蓝色还是蓝绿色？

> 原文:[https://hack aday . com/2019/03/10/bash-pipeline-puzzle-green-blue-or-blue-green/](https://hackaday.com/2019/03/10/bash-pipeline-puzzle-green-blue-or-blue-green/)

[马雷克·吉布尼]提出了一个有趣的难题。下面的 bash 命令行打印了什么？

```
( echo red ; echo green 1>&2 ) | echo blue
```

你会认为它打印三条线:红色，绿色和蓝色。但是你会不会惊讶的发现，它有时候可以输出“蓝绿色”，有时候只是输出蓝色。第一个惊喜是它不是决定性的。但是第二件令人惊讶的事情是，有时候整行的左边部分什么都不做。[Chris Siebenmann]做了分析，并在最近的一篇博客文章中解释了发生的事情。

在你点击链接或进一步阅读之前，你可能想看看你是否能推断出发生了什么。放弃？这里有一个提示:部分解决方案取决于 echo 内置在 shell 中这一事实。

分解命令行，左边部分将会派生出一个 subshell。“echo blue”部分在原始 shell 中运行。记住，既然 echo 是内置的，就不会有更多的进程。红色回声被输送到右边部分，它忽略输入。然而，绿色部分重定向到 stderr 流，所以您得到蓝色和绿色的某种组合是有道理的，但是为什么有时您只得到蓝色呢？

根据[Chris]的说法，有三种可能的结果:

1.  左侧打印绿色，并在右侧尝试写入之前退出。你得到绿色和蓝色。
2.  左侧打印红色，右侧打印蓝色，然后左侧的第二部分打印绿色。你得到蓝绿色。
3.  回声蓝先跑，后结束。echo red 随后试图写入一个损坏的管道，并以 SIGPIPE 信号结束。

这是一个很好的例子，说明了简单的工具如何以令人惊讶的方式组合在一起，有时即使是最简单的命令也需要理解看似不重要的底层细节。

当然，您可能会认为这一行不是 shell 脚本的一个很好的例子。这是真的，但是你并不总是选择你正在分析的代码。

当[编写 shell 脚本](https://hackaday.com/2017/07/21/linux-fu-better-bash-scripting/)时，有很多事情需要考虑。甚至还有一个用于[检查脚本](https://hackaday.com/2017/03/29/lint-for-shell-scripters/)的工具，类似于 lint 检查 C 程序的方式。