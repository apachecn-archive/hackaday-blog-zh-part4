# 类固醇警告——静态代码分析工具

> 原文:[https://hack aday . com/2018/12/12/warnings-on-steroids-static-code-analysis-tools/](https://hackaday.com/2018/12/12/warnings-on-steroids-static-code-analysis-tools/)

不久前，我们讨论了利用编译器警告作为第一步的[，以使我们的 C 代码不容易出错，并提高其总体稳定性和质量。我们现在知道 C 编译器本身可以帮助我们，但我们也看到了它的局限性。虽然它警告我们最明显的错误和可疑的代码构造，但当事情变得有点复杂时，它会让我们无所适从。](https://hackaday.com/2018/11/06/warnings-are-your-friend-a-code-quality-primer/)

但是，这并不意味着编译器警告是无用的，我们只是需要看清它们的本质:这是第一步。因此，今天我们将采取下一步，看看其他一些常见的静态代码分析工具，它们可以让我们对代码有更多的了解。

您可能认为在这个时代自愿选择 C 作为主要语言可能显得怀旧或不合时宜，但是您可以宣扬和氧化所有您想要的:C 不会去任何地方。因此，让我们利用现有的工具，帮助我们编写更好的代码，并挑战 C 语言臭名昭著的陷阱。静态代码分析的一般概念是通用的。毕竟，很多时候 bug 或其他问题不一定是由语言引起的，而是代码逻辑中的一些一般性缺陷。

## 编译器警告摘要

但是让我们先回到编译器警告。如果我们回忆一下`nonnull`属性，该属性表明函数的参数不能也不会是`NULL`，我们会发现编译器在这个问题上是非常短视的:

```

extern void foo(char *) __attribute__((nonnull));

void bar(void) {
    char *ptr = NULL;

    foo(NULL); // warning
    foo(ptr);  // no warning here
}

```

编译器会对`foo(NULL)`调用发出警告，因为它明显违反了`nonnull`声明，但它不会意识到第二个调用最终也会将`NULL`作为参数传递。公平地说，为什么它应该理解，它的主要工作是从我们的源代码生成机器可读的可执行文件？

现在，这个例子是一个相当明显的例子，虽然编译器可能不会警告它，但它仍然很容易被发现。如果您有适当的代码审查实践，那么检测这个错误应该是简单的。但有时只有我们自己，没有其他开发人员来审查我们的代码，由于疲劳或其他原因，它可能会从我们眼前溜走。其他时候，隐藏在下面的潜在问题不太明显，可能需要一系列不幸的事件才能成为实际问题。我们必须在心理上仔细考虑每一个可能的执行路径，以确保一切顺利。

无论哪种方式，用体力劳动去做实际上迫切需要自动化的事情听起来都是浪费时间。因此，让我们来看看一些常用的工具。请注意，我们在这里仅仅触及了皮毛，这更像是对可用工具的简要概述。

## 静态代码分析工具

静态代码分析包括仅仅通过分析源代码来检查我们的程序，而不是执行它。例如，它不会考虑在一组函数中处理的实际数据，而是确保数据以安全和逻辑的方式传递和处理。这当然是一个问题，在这个问题上投入资金将为您带来更大更闪亮的工具，虽然它们在专业世界中有自己的位置，但我们将专注于日常黑客在业余时间项目上的修补，并看看开源社区提供了什么。

虽然最初的例子很好地回忆了编译器警告的缺点，但是用一个简单的场景无法展示其他工具的全部优势。最好的方法是通过在您自己的代码、其他一些您经常编译或使用的工具和程序上使用它们，或者在 GitHub 等网站上浏览一些随机的项目来自己看看。

### 叮当声

对，就从`clang`说起吧。但是在你开始抱怨并认为“已经放弃编译器警告并继续前进”之前，`clang`比它的编译器基础设施还有更多，比如[它自己的静态代码分析器](http://clang-analyzer.llvm.org/scan-build.html)。它支持与`clang`相同的目标，并且可以通过在通常的构建命令之前加上`scan-build`命令来调用。

```

$ scan-build clang -o foo foo.c

```

分析器不一定需要`clang`作为编译器，所以这也可以工作:

```

$ scan-build gcc -o foo foo.c

```

或者你只需运行`make`:

```

$ scan-build make
...
scan-build: n bugs found
scan-build: Run 'scan-view /tmp/scan-build-xyz' to examine bug reports.
$

```

虽然您不能简单地将源文件列表传递给`scan-build`，而是需要执行实际的构建，但是它的优点是编译和分析可以同时进行。这使得分析成为构建过程本身的一部分，而不是您应该始终记住的一些乏味的额外任务。毕竟，实际使用工具并根据工具所能提供的东西采取行动取决于我们。它们对我们心流的干扰越少，我们就越不愿意最终使用它们，看看它们会说些什么。

说到看看他们要说什么，如果您再看一下最后一行输出`scan-build`显示的内容，您会发现一个显示分析结果的命令。在`scan-view`命令后面是一个简单的 Python 脚本，它启动一个本地 web 服务器并在您的浏览器中打开报告概述页面。如果你只是在浏览器中打开`file:///tmp/scan-build-xyz/index.html`，你会得到或多或少的相同结果，如果你不喜欢任何不能在终端中运行的东西，这在你常用的文本模式浏览器中已经足够好了。

当运行`scan-build`时，它可能会输出，例如在一个特定的地方`NULL`可能会被传递到它不应该被传递的地方，但它不会告诉你在什么情况下。这里基于浏览器的报告的伟大之处在于，您可以浏览代码，并一步一步地跟踪每个循环和条件分支，潜在的问题如何变成 bug。请记住，该程序从来没有真正运行过，所以您可能会遇到一些假阳性，这些假阳性在现实中从来都不是有效的或可能的情况。反过来说，每个工具都有不同的侧重点，所以有些问题甚至可能不被考虑。

静态代码分析绝不是一个放之四海而皆准的工作，因此使用多种工具也无妨。好吧，那我们继续下一个吧。

### (sp)功能区

静态代码分析最著名的工具可能是`lint`，它已经成为静态代码分析本身的同义词。在你的普通 Linux 发行版中，你会发现 [`splint`](http://www.splint.org/) 是它的一个实现。与`clang`的静态分析器不同，`splint`将获取源文件并分析它们，而不运行任何编译。

```

$ splint foo.c
...
Finished checking --- 3 code warnings
$

```

`splint`是一个相当复杂的工具，有许多标志来启用和禁用检查，并控制其行为。它还有自己的源代码注释，用特殊格式的注释`/*@annotation@*/`定义，这将影响分析和报告的内容。您是否喜欢代码中的这种(有争议的)噪音当然取决于您。

你可能知道最新发布的`splint`是 2007 年的。当然，这并不意味着它过时了，许多潜在的问题是永恒的，并且已经存在了超过 11 年。理论上，你也应该能够使用`splint`进行代码定位，例如 AVR 微控制器，但这可能会强调“理论”部分。通常需要对输出进行大量的调整和挖掘，才能充分利用它。如果你足够好奇和坚持,[夹板手册](http://www.splint.org/manual/)可能是一个好的开始。

### flawfinder

如前所述，每个工具通常有不同的关注领域。对于 [`flawfinder`](https://dwheeler.com/flawfinder/) ，重点是安全漏洞，特别是[【CWE】](https://en.wikipedia.org/wiki/Common_Weakness_Enumeration)常见漏洞列举。虽然这为不安全的 C 函数和实践提供了一个很好的概述，但它主要是在检测到危险构造时发出警告。它似乎并不检查代码中是否存在实际问题，只是在你最终错误地使用它的情况下*可能会出现*。

尽管如此，单词*在 CWE 很常见*是有原因的，所以即使你确保了你当前的实现一切正常，偶尔提醒一下那些常见的弱点也无妨，而不必主动深入每个手册页。顺便说一下，作者或者说`flawfinder`也写了[一本关于安全编程](https://dwheeler.com/secure-programs/)的书，并在 GNU 自由文档许可下发布，如果你想阅读更多关于这个主题的内容。

### cppcheck

我们要提到的最后一个工具是 [`cppcheck`](http://cppcheck.sourceforge.net/) ，尽管它的名字容易让人误解，它涵盖了 C++和 C，主要关注未定义的行为。如果你能负担得起或者已经拥有米斯拉规则文本，你也可以把它们包括进来。其中一些也是现成的，当然，即使没有购买规则文本，它仍然是一个功能齐全的代码分析器。

还允许你编写自己的规则，并以定制的可格式化文本或 XML 的形式报告它的发现，并提供与大多数常见 ide 的集成。如果您想偶尔点击一些东西，或者在控制台文本的墙壁中跋涉而感到有些厌烦，它还提供了一个图形用户界面作为命令行的替代，它将显示报告的问题以及匹配的源代码。

### 二等奖；荣誉奖；H 奖

另一个听起来很有希望并且值得研究的工具是 [`frama-c`](https://frama-c.com/) 。

## 限制

显然，没有一个工具能够分析和检测到每一个可能的缺陷，否则这个列表会短得多。就像一些工具会遗漏一些问题一样，它们也可以通过热情地报告结果证明是误报的内容来进行过度补偿。如前所述，您需要自己决定哪些警告是有效的，以及您需要解决的问题。这可能看起来很乏味，而且浪费时间——这正是这些工具应该帮助您避免的。也许经常是这样，但是它也会帮助你更好地理解你自己的代码，并且从一个你从来没有考虑过的角度看到它的一些含义。当它发现一个罕见的错误时，它会得到回报。

在对这些工具进行了一些初步的摆弄之后，你还会注意到，其中一些工具需要进行大量的调整才能发挥最大的作用，就像在`splint`中已经提到的那样。因此，从长远来看，你需要再次权衡投资这些时间是否值得。与编译器警告不同，从代码分析工具中消除每一个警告可能不是最有价值的过程，尤其是当这么多是误报的时候。建议编码员自行决定。

当然，静态代码分析在设计上有局限性，实际数据及其含义既不被考虑也不被检查。一个`int`就是一个`int`，只要我们不导致溢出或其他违反语言规范的操作，或者在未定义的领域结束，从静态代码分析的角度来看，我们很可能是好的。例如，它不会检测或关心`int`的值是否必须在某个范围内才能有意义，并且不会对程序上下文的其余部分造成伤害。我们必须实际执行我们的代码才能知道那里发生了什么。话虽如此，下一次我们将讨论断言，以及为什么尽早发布会更好。