# 抓住线程:自旋锁与互斥锁

> 原文：<https://hackaday.com/2019/03/24/grabbing-the-thread-spinlocks-vs-mutexes/>

进入操作系统的杂草是令人生畏的工作。尤其是当所涉及的操作系统是一个功能齐全的现代 PC 操作系统，有数百万行代码一起工作以无缝集成硬件和软件时。当处理器一次只能处理一件事情时，一个这样的操作系统“杂草”正在计算如何处理同时进行的任务。为此，您将会看到自旋锁和互斥锁之间的[差异。](https://nathanpetersen.com/2019/02/17/optimizing-for-workloads-linux-spinlocks-vs-mutexes/)

这两种方法都是为了确保处理器在继续下一个任务之前充分完成一个任务。现代计算机的速度非常快(甚至忽略了多核)，看起来好像它们正在同时做许多事情。为了保持这种错觉，任务需要在一定时间内将处理器锁定在特定任务上。当然，执行下一个任务的队列会变得复杂，因为经常有许多任务等待使用处理器时间。自旋锁是一种简单的持有处理器的方式，互斥锁是一种稍微复杂一点的方式，但是哪一种方式最有效地利用系统资源并不是那么简单。

如果你曾经对操作系统的细节感兴趣，这本书会深入到我们大多数人从未考虑过的特性的复杂性。不过，它绝对值得一读，而且作者显然是位专家，写得非常好。如果你想挑战操作系统，你也可以[构建自己的操作系统](https://hackaday.com/2018/01/19/roll-your-own-raspberry-pi-os/)。