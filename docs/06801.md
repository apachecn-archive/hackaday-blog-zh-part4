# 三星的闰月 Bug 告诉我们不要逃避测试

> 原文:[https://hack aday . com/2020/06/15/samsungs-leap-month-bug-teaches-not-skip-on-testing/](https://hackaday.com/2020/06/15/samsungs-leap-month-bug-teaches-not-to-skimp-on-testing/)

日期和时间的处理是很难的，这是软件开发的一个丑陋的事实，总有一天我们都会学到这一点。当然，这可能看起来像是一些日常琐事，您可以轻松地自己实现，而不需要依赖第三方库。我的意思是，它基本上只是在一个接一个的基础上增加秒，滚动到分钟，从那里继续滚动到小时，天，月，直到你到达年。在每年的二月四日加上偶尔的额外一天，你就可以走了，对吗？

显然不是。假设你首先想到了闰年——遗憾的是这不是给定的——有几个例外，比如导致 1900 年和 2100 年成为常规年份，而 2000 年仍然是闰年。然后是闰秒，不规律的出现。但是仍然有更多的陷阱在等着我们。例证:早在 5 月份，中国日历[的](https://www.scmp.com/tech/big-tech/article/3086110/why-did-some-samsung-smartphones-crash-china-may-23)[农历闰月](https://en.wikipedia.org/wiki/Chinese_calendar)处理失误，导致全中国的三星手机都变成了砖头。虽然您可能不打算在自己的项目中添加对非公历日历的支持，但这只是又一个意想不到的古怪行为的例子。除了，三星在这里做了一切。

发生了什么事？

## 许多日历的故事

除了公历(没有关系)，自从时间的文字发明以来，各种各样的日历已经存在，通常分为三类:

*   [*太阳历*历法](https://en.wikipedia.org/wiki/Solar_calendar)完全基于太阳的年周期，如公历
*   [*阴历*历法](https://en.wikipedia.org/wiki/Lunar_calendar)完全基于月亮的月周期，就像伊斯兰历一样
*   [*日月*历法](https://en.wikipedia.org/wiki/Lunisolar_calendar)基于月亮的月周期，但与太阳的年周期一致，像大多数历史历法，包括传统的中国历法

考虑到一个太阳年中(大约)额外的四分之一天，我们每四年积累并挤进二月，以防止季节漂移太远，当我们想对月亮的大约 29.5 天周期做同样的事情时，事情肯定有点复杂。它只是加起来不太好，而*闰月*是阴阳历的结果，时不时地给一年增加整整一个月。另一方面，纯粹的阴历根本不关心太阳，因此忽略任何修正以保持季节同步。

如果你想知道为什么中国新年或复活节没有固定的日期，但仍然在一年中的同一时期，阴阳历就是你的答案——就像农历解释了为什么斋月总是在每年完全不同的时间。

## 虫子和石头可能会堵塞你的手机

发生了什么事？[高叶]仔细研究了这个问题[，并写了一份关于调查结果的详细描述](https://www.zhihu.com/question/396666758/answer/1245994988)。这篇文章是中文的，页面似乎不喜欢通过谷歌翻译加载，所以以防你的浏览器不会为你翻译，[这里有它的 PDF](https://hackaday.com/wp-content/uploads/2020/06/samsung-bug-analysis.pdf)。好吧，让我们仔细看看，并补充一些细节，以防你对 Android 不太熟悉。

正如文章所述，问题本身源于永远在线显示(AOD)服务，这是一些 Android 设备提供的一项功能，可以在手机休眠时在屏幕上显示基本信息，比如当前时间和日期。就受影响的三星手机而言，根据中国日历，这一天是中国历上的日子。午夜时分，闰月开始了，AOD 的服务出人意料地崩溃了。

作为一个系统服务，Android 只是重启了服务，不出所料，这并没有解决问题，再次导致立即崩溃。清洗和重复足够频繁，操作系统最终决定其关键组件之一无法运行，并作为缓解关闭并重新启动到其恢复模式。如果这种情况发生在普通的应用程序中，崩溃会更麻烦，因为应用程序会一直崩溃，但这样一来，手机基本上就被砖砌了。

在开始时讨论了所有自制的日期和时间实现之后，显而易见的假设是闰月处理中的一个缺陷导致了这次崩溃。然而，根据[高叶]挖掘出的代码，逻辑实际上是这样的:

```

chinaLunar = (sSolarLunarConverter.isLeapMonth()
        ? context.getResources().getString(R.string.common_date_leap_month) + months[convertMonth]
        : months[convertMonth])
    + days[convertDay];

```

尽管处理(soli)阴历看起来很复杂，但对于大多数月份来说，中国日历都有一个实用的解决方案，只需在插入月份的名称前加上“闰”这个词。今年闰月落在第四个月之前，所以它的名字变成了“闰四月”，之后是正常的“第四个月”。代码类似于这种逻辑。

查看分析中的堆栈跟踪，崩溃实际上是由于未能检索到“leap”前缀字符串资源`common_date_leap_month`的字符串资源而导致的。虽然这在很高的层面上解释了这个问题，但实际上它提出的问题比它回答的问题要多，主要是服务最初是如何陷入这种境地的。为了理解它，我们来看看 Android 是如何处理字符串和其他资源的。

## Android 资源处理

除了数组、整数、任何与 UI 布局相关的东西，以及几乎所有其他没有硬编码的东西，字符串都是在 XML 资源文件中定义的，这些文件与应用程序的 Java(或 Kotlin)源代码是分开的。每种资源类型都有一个用于默认值的公共文件，以及一些附加文件，这些文件可以选择用更特定的值(如不同的 UI 布局、设备功能或区域设置)来覆盖这些默认值。

例如，在一个`res/values/strings.xml`文件中，可以用英语作为默认选项来定义一个字符串，如下所示:

```

<string name="tongue_twister">Peter Piper picked a peck of pickled peppers.</string>

```

它的本地化德语对应物可以在`res/values-de/strings.xml`中以同样的方式定义(注意值路径中的语言代码):

```

<string name="tongue_twister">Fischers Fritz fischt frische Fische.</string>

```

在构建过程中，整个资源集合被收集并编译成一个资源对象文件，即`some.package.R`文件。为我们的示例生成的中间 Java 文件将包含这样的绕口令字符串:

```

package some.package;

public final class R {
  ...
  public static final class string {
    ...
    public static final int tongue_twister=0x7f0d001d;
    ...
  }
  ...
}

```

如您所见，这既不是一个实际的字符串，也不包含关于翻译的信息，而只是一个作为引用的整数。在应用程序代码中，我们将简单地以`R.string.tongue_twister`的形式访问字符串，系统将在运行时填充其余的内容。根据设备的设置，三分之一的情况会发生:

1.  如果设备设置要求显示翻译后的字符串，并且存在特定于语言的字符串，则会显示该字符串
2.  如果没有特定于语言的翻译可用(或不需要)，则显示默认字符串
3.  如果根本没有对资源的引用，就会抛出一个`NoSuchFieldError`

回到[高叶]的分析中的堆栈跟踪，第三种情况正是在受影响的设备中针对`common_date_leap_month`字符串资源发生的情况。也就是说，代码使用该字符串资源，但是在设备上运行的可执行文件不包含它的有效条目。

你现在可能会想，这是编译器能够并且*应该*已经捕捉到的东西——你是绝对正确的。这就是这个问题变得既有趣又发人深省的地方。

## 未能失败

通常，使用不存在的`R.string.something`资源值确实会导致错误，就像试图访问任何其他不存在的字段或方法一样。同样，C 编译器会抛出一个关于未声明的标识符的错误，或者警告一个隐式声明的函数，并让链接器最终抛出一个错误。

大约在 2018 年 10 月的某个时候，有问题的字符串条目从资源中消失了，但仍在源代码中使用——即代码没有改变，但它使用的字符串值从 XML 文件中删除了。此时，编译应该已经失败了，然而它没有。[高叶]总结道，包和日历的依赖链中的版本不匹配可能会导致这样一种情况，构建系统很满意，并且可以很好地编译，但是应用程序在运行时会失败。

检查整个应用程序(包括资源和源代码)中出现的`common_date_leap_month`表明，在正确的版本中，资源在两个不同的包中可用:

1.  `com.samsung.android.app.aodservice`
2.  `com.samsung.android.uniform`

第二个包也包含前面显示的闰月处理的逻辑，并且是导致崩溃的`NoSuchFieldError`的来源。现在，我手头没有源代码，也没有构建过程的细节，所以我不能肯定地说，但是从两个包*中删除资源条目*可能会成功，这对我来说似乎是合理的。

让我们假设一个场景，在重新编译第一个`aodservice`包之前编译第二个`uniform`包:虽然`uniform`部件不会在它自己的包中找到`common_date_leap_month`资源，但由于复杂构建系统中的缓存和其他机制可以加快构建时间，它可以成功地在旧的`aodservice`部件中找到引用。另一方面，由于`aodservice`包不使用`common_date_leap_month`本身，以后重新编译它不会介意它现在丢失了。

换句话说，这两个部分在编译时都是正确的，但是一旦它们被打包在一起并安装到设备上，丢失的资源就变成了一个定时炸弹，现在已经爆炸了。

好消息是，最初的问题已经在 2019 年 6 月得到解决，因此影响没有想象中那么糟糕。坏消息是，人们仍然受到影响，这意味着在修复后的 9 个多月里，他们要么没有，要么不能更新他们的手机。没有进一步的细节，首先很难说字符串资源是如何丢失的。

最终，整个问题本质上是一系列不幸的事件，尽管人们对 Java 或智能手机供应商有不同的看法，但仍在问“谁该受到责备？”我没有一个简单的答案——反正这样的答案也没多大用处。它发生了，并且它首先发生的事实是我们应该在这里关注的，并且主要再次表明软件是困难的，没有什么事情像人们可能认为或希望的那样清楚和明显。

虽然这个问题也没有简单的答案，但更好的问题是:我们能从中学到什么？

## 要吸取的教训

在我通读了错误分析之后，我开始思考如何避免这样的错误。最好的情况是，它发生在一个足够常见的地方，快速检查以验证一个人的变化会立即检测到它，但如果它需要像闰月这样的特殊情况，那就不太可能了。自动化测试浮现在脑海中，考虑到这篇文章的标题，这显然是我想表达的意思。不是说三星没有适当的测试，我肯定他们有，至少在一定程度上有。

我会自己编写一个测试用例来检查字符串资源是否存在吗？不，不是为了检查它的存在。眼前的问题也不会改变这一点，不管事后看来这个错误有多明显。而事情就是这样，这个具体的错误现在*很明显*，但下一种情况就不会了。从本质上讲，我们必须验证每一个资源的价值，以确保我们在未来捕捉到类似的场景，这无疑是朝着错误的方向迈出的一步。我们不妨开始验证常量是否具有我们赋予它们的值。

显然，我们需要更好的方法。通常的选择是单元测试，因为这几乎是一般开发人员想进行的所有测试——在好的一天。将 calendar 方法返回的字符串与一组选定日期的预期值进行比较是教科书式的测试案例。如果闰月包含在这些日期中，该测试甚至可能像设备在野外那样崩溃，并足够早地检测到问题，除非测试在`uniform`组件中运行，并使用相同的过时的`aodservice`部分，这将我们带回起点。

尽管如此，与检查资源值是否存在相比，单元测试是一个更好的解决方案，尽管日历错误仍然可能被忽略，但这是一个可靠的测试。当然，使用最终的组合应用程序运行这种单元测试将是最好的解决方案——但是话说回来，当我们知道我们在寻找什么时，说起来很容易。这里没有通用的答案，除了测试是一个复杂的主题，与开发相比需要完全不同的思维方式。

问题是，作为开发人员，我们喜欢说服自己我们的代码是完美的，所以编写无偏见的测试用例可能会很困难。更不用说对待测试的普遍态度了，它与[代码文档](https://hackaday.com/2019/03/05/good-code-documents-itself-and-other-hilarious-jokes-you-shouldnt-tell-yourself/)和[错误处理](https://hackaday.com/2019/01/22/crash-your-code-lessons-learned-from-debugging-things-that-should-never-happen/)一起构成了人们主要用来让别人远离他们的烦恼的神圣三位一体，而不是为了他们自己的利益利用它。

开发人员和测试人员之间的普遍差异也没有帮助。我们将测试人员视为敌对的煞风景者，他们试图破坏我们的创作，他们确信我们在某个地方搞砸了，以证明这一点为己任——我确信这种厌恶是双向的。当然，从某种意义上来说，测试人员和开发人员确实在相互对抗，但是这并不意味着不能以合作的方式进行。与其证明谁该受责备，不如一起制定出经过深思熟虑的测试用例，并在此过程中互相学习，这样肯定会结出更丰硕的成果。

如果有什么不同的话，三星的问题应该告诉我们，漏洞潜伏在最奇怪的地方，解决它们可能需要一些跳出框框的思考。将软件开发者和决心打破它的人的观点结合起来，可能会激发灵感，并有助于考虑他们自己可能都没有看到的角度。与错误处理一样，与其想“这永远不会发生”，我们不如想办法增加一个额外的检查或测试用例来确保它真的不会发生——并为*发生*的那一天提前一步。