# 托尼·布鲁克和 Autocode——第一种高级语言

> 原文:[https://hack aday . com/2020/01/02/Tony-brooker-and-autocode-a-forgot-tale/](https://hackaday.com/2020/01/02/tony-brooker-and-autocode-a-forgotten-tale/)

到目前为止，计算机科学领域已经不可否认地改变了几乎每个人的世界。当然，对于你这样的普通读者来说是这样，但对于你周围的每个人来说也是如此，无论他们是自己在这个领域工作，还是仅仅享受它带来的便利。曾经是少数人的高度专业化的利基领域，现在已经发展成为一门学科，不仅创造了现代最大的行业之一，还彻底改变了其他所有行业，有些甚至超过几倍。

所有这一切令人着迷的部分是它到达这里所用的时间相对较短，并因此有幸生活在一个时代，在这个时代，一些先驱和创新者，众所周知的巨人，我们每个人都站在他们的肩膀上，仍然在我们中间。令人悲伤的是，其中一位，早期编程语言概念 Autocode 的先驱[Tony Brooker]于 11 月去世。到了令人瞩目的 94 岁高龄，真正令人难过的是，这可能是你第一次听到他的名字，而且很有可能你也从未听说过 Autocode。

但是 Autocode 可能是第一种高级计算机语言，因此在你今天编码的任何东西的开发中扮演了一个基本的角色。因此，为了纪念[托尼·布鲁克]，让我们记住他用 Autocode 所做的工作，以及它所代表的计算机科学史上的一次飞跃。

## 早期

当谈到古代编程语言时，Fortran 和 COBOL 总是值得一提的首选语言。创建于 20 世纪 50 年代后期，这些语言被一种近乎神话的氛围所包围。比语言本身年轻得多的开发人员从未见过 COBOL 语言，他们会互相讲述同样神秘的故事，讲述一个曾经在实验室或其他难以置信的环境中使用 COBOL 语言的远亲。

年龄在这里并不重要；assembly 甚至更古老，它不太可能会失去它的相关性。然而，不同之处在于汇编是一种低级语言，而大多数其他语言，包括 Fortran 和 COBOL，都是高级语言。汇编编程意味着写入处理器提供的任何指令集。汇编语言只是机器所说的原始位的便捷助记符。另一方面，高级语言不太关心处理器的指令集，而是将这些细节抽象出来，更多地与人类思维的动态产生共鸣。

以一个简单的乘法为例:在典型的高级语言中，你可以简单地写`a = b * c`，而在汇编语言中，你可以写目标处理器本身所知道的关于乘法的任何东西。您可能会将被乘数加载到专用寄存器中，CPU 可能会有一条乘法指令，或者可能需要循环执行一系列加法。你必须知道芯片是如何工作的。在高级语言中，编译器的任务是找出如何进行实际的乘法运算，并为其创建相应的汇编代码。

## 完整事物中缺少的一个环节

那么 Autocode 如何适应这一切，它到底是什么？它是在汇编发明之后，但在任何高级语言出现之前设计的。组装本身在当时是一个相当热门的新话题，那时人们还在手工雕刻零件。嗯，显然不是字面上的意思，但是给那个时代的计算机“编程”是乏味的、不直观的、容易出错的工作。除了由[Alick Glennie]开发的一个名为 Autocode 的类似编译器的早期版本。

早期的一台计算机是曼彻斯特马克 1 号，它是 [*婴儿*](https://en.wikipedia.org/wiki/Manchester_Baby) 的直接继承者，这台计算机是在曼彻斯特大学的计算机实验室里与艾伦·图灵一起工作的。据说它有一个相当糟糕的指令集，使得机器语言编程的乏味本质更加糟糕，这是创建 Autocode 的第一个动机:驯服机器。

[![](../Images/ae16a048eee3114af9453cbeee7f00d3.png)](https://hackaday.com/wp-content/uploads/2020/01/mark1.jpg)

The [University of Manchester’s](http://curation.cs.manchester.ac.uk/computer50/www.computer50.org/mark1/ip-mm1.mark1.html) historic Mark 1 on the left, one rack of Baby on the right.

[Glennie]的 Autocode 版本是一个语法良好的包装器，在其他方面仍然依赖于机器，我们不得不将其归类为低级语言。直到我们故事的主人公[Tony Brooker]第二次尝试 Autocode 的想法，第一种高级语言才被编写出来。

传说，有一天，在他作为计算机研究员返回剑桥的路上，他突然出现在曼彻斯特大学计算机实验室，向[艾伦·图灵]介绍自己和他的工作。他们对工作的共同兴趣得到了保证，[托尼·布鲁克]加入了计算机实验室，创建了他一生的工作，作为他使 Mark 1 更容易使用的任务的一部分:设计一种具有人类可读语法的直观语言，这种语言将隐藏所有低级的讨厌之处，这种语言不需要浪费无数时间学习和破译硬件的每一个细节，并最终将底层硬件或多或少地变成程序员不应该太担心的无关紧要的细节。简而言之，它被规划为一门真正的高级语言。

从 1954 年开始开发， [Mark 1 Autocode](https://warwick.ac.uk/fac/sci/dcs/people/abhir_bhalerao/mark1_autocode_interpreter/) 在第二年就准备好了，除了硬件独立性，它还支持浮点运算。虽然它在命名约定和语法上有一些限制，但它在曼彻斯特取得了巨大的成功。[Tony Brooker]继续发展 Autocode 的概念，不仅用于其他机器，而且用于语言创造本身的概念。在 Autocode 的道路上越走越远，他在 1960 年创造了第一个[编译器-编译器](https://en.wikipedia.org/wiki/Compiler-compiler)，在开发新语言方面变得几乎不可阻挡。

## 一些可以建立的东西

在一个汇编实际上是操作计算机的便利的缩影的时代，[托尼·布鲁克]的 Autocode 版本的概念将编程带到了一个新的水平，并为一个全新的语言领域的到来铺平了道路。没有单一的自动编码语言，就像没有单一的汇编语言一样。Autocode 可能最好被认为是一个已经发展到编译、高级语言领域的原则。

不像 COBOL 或 Fortran，没有人再用 Autocode 编码了。这是一个几乎被遗忘的过去的遗迹，不管它曾经在计算机科学的历史上扮演过什么角色。但是 Autocode 中包含的思想仍然存在。毫无疑问，高级编程语言的产生是不可避免的，然而今天很难完全理解几十年前像托尼·布鲁克这样的先驱真正迈出第一步所做的工作。值得铭记。